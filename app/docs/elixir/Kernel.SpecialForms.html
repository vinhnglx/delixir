    <!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.15.1">
    <title>Kernel.SpecialForms – Elixir v1.4.4</title>
    <link rel="stylesheet" href="dist/app-af302bfcc4.css" />
    
      <link rel="canonical" href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html" />
    
    <script src="dist/sidebar_items-74d75774da.js"></script>
  </head>
  <body data-type="modules">
    <script>try { if(localStorage.getItem('night-mode')) document.body.className += ' night-mode'; } catch (e) { }</script>

    <div class="main">
<button class="sidebar-toggle">
  <i class="icon-menu"></i>
</button>
<section class="sidebar">

  
  <a href="http://elixir-lang.org/docs.html" class="sidebar-projectLink">
    <div class="sidebar-projectDetails">
      <h1 class="sidebar-projectName">
        Elixir
      </h1>
      <h2 class="sidebar-projectVersion">
        v1.4.4
      </h2>
    </div>
    
      <img src="assets/logo.png" alt="Elixir" class="sidebar-projectImage">
    
  </a>

  <div class="sidebar-search">
    <i class="icon-search"></i>
    <input type="text" class="sidebar-searchInput" placeholder="search" autocomplete="off" />
  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list" href="#full-list">Pages</a></li>

    
      <li><a id="modules-list" href="#full-list">Modules</a></li>
    

    
      <li><a id="exceptions-list" href="#full-list">Exceptions</a></li>
    

    
      <li><a id="protocols-list" href="#full-list">Protocols</a></li>
    
  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">


      <h1>
        <small class="visible-xs">Elixir v1.4.4</small>
        Kernel.SpecialForms
        
        
          <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1" title="View Source" class="view-source" rel="help">
            <i class="icon-code"></i>
          </a>
        
      </h1>

      
        <section id="moduledoc">
          <p>Special forms are the basic building blocks of Elixir, and therefore
cannot be overridden by the developer.</p>
<p>We define them in this module. Some of these forms are lexical (like
<a href="#alias/2"><code class="inline">alias/2</code></a>, <a href="#case/2"><code class="inline">case/2</code></a>, etc). The macros <code class="inline">{}</code> and <code class="inline">&lt;&lt;&gt;&gt;</code> are also special
forms used to define tuple and binary data structures respectively.</p>
<p>This module also documents macros that return information about Elixir’s
compilation environment, such as (<a href="#__ENV__/0"><code class="inline">__ENV__/0</code></a>, <a href="#__MODULE__/0"><code class="inline">__MODULE__/0</code></a>, <a href="#__DIR__/0"><code class="inline">__DIR__/0</code></a> and <a href="#__CALLER__/0"><code class="inline">__CALLER__/0</code></a>).</p>
<p>Finally, it also documents two special forms, <a href="#__block__/1"><code class="inline">__block__/1</code></a> and
<a href="#__aliases__/1"><code class="inline">__aliases__/1</code></a>, which are not intended to be called directly by the
developer but they appear in quoted contents since they are essential
in Elixir’s constructs.</p>

        </section>
      

      
        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <i class="icon-link"></i>
            </a>
            Summary
          </h1>
          

          
  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
    <div class="summary-row">
  <div class="summary-signature">
    <a href="#%25/2">%</a>
  </div>
  
    <div class="summary-synopsis"><p>Creates a struct</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#%25%7B%7D/1">%{}</a>
  </div>
  
    <div class="summary-synopsis"><p>Creates a map</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#&amp;/1">&amp;(expr)</a>
  </div>
  
    <div class="summary-synopsis"><p>Captures or creates an anonymous function</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#./2">left . right</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines a remote call or an alias</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#::/2">left :: right</a>
  </div>
  
    <div class="summary-synopsis"><p>Used by types and bitstrings to specify types</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#%3C%3C%3E%3E/1">&lt;&lt;args&gt;&gt;</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines a new bitstring</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#=/2">left = right</a>
  </div>
  
    <div class="summary-synopsis"><p>Matches the value on the right against the pattern on the left</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#%5E/1">^var</a>
  </div>
  
    <div class="summary-synopsis"><p>Accesses an already bound variable in match clauses. Also known as the pin operator</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#__CALLER__/0">__CALLER__</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the current calling environment as a <a href="Macro.Env.html"><code class="inline">Macro.Env</code></a> struct</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#__DIR__/0">__DIR__</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the absolute path of the directory of the current file as a binary</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#__ENV__/0">__ENV__</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the current environment information as a <a href="Macro.Env.html"><code class="inline">Macro.Env</code></a> struct</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#__MODULE__/0">__MODULE__</a>
  </div>
  
    <div class="summary-synopsis"><p>Returns the current module name as an atom or <code class="inline">nil</code> otherwise</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#__aliases__/1">__aliases__(args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Internal special form to hold aliases information</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#__block__/1">__block__(args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Internal special form for block expressions</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#alias/2">alias(module, opts)</a>
  </div>
  
    <div class="summary-synopsis"><p><a href="#alias/2"><code class="inline">alias/2</code></a> is used to setup aliases, often useful with modules names</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#case/2">case(condition, clauses)</a>
  </div>
  
    <div class="summary-synopsis"><p>Matches the given expression against the given clauses</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#cond/1">cond(clauses)</a>
  </div>
  
    <div class="summary-synopsis"><p>Evaluates the expression corresponding to the first clause that
evaluates to a truthy value</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#fn/1">fn
  [clauses]
end</a>
  </div>
  
    <div class="summary-synopsis"><p>Defines an anonymous function</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#for/1">for(args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Comprehensions allow you to quickly build a data structure from
an enumerable or a bitstring</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#import/2">import(module, opts)</a>
  </div>
  
    <div class="summary-synopsis"><p>Imports functions and macros from other modules</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#quote/2">quote(opts, block)</a>
  </div>
  
    <div class="summary-synopsis"><p>Gets the representation of any expression</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#receive/1">receive(args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Checks if there is a message matching the given clauses
in the current process mailbox</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#require/2">require(module, opts)</a>
  </div>
  
    <div class="summary-synopsis"><p>Requires a given module to be compiled and loaded</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#super/1">super(args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Calls the overridden function when overriding it with <a href="Kernel.html#defoverridable/1"><code class="inline">Kernel.defoverridable/1</code></a></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#try/1">try(args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Evaluates the given expressions and handles any error, exit
or throw that may have happened</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#unquote/1">unquote(expr)</a>
  </div>
  
    <div class="summary-synopsis"><p>Unquotes the given expression from inside a macro</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#unquote_splicing/1">unquote_splicing(expr)</a>
  </div>
  
    <div class="summary-synopsis"><p>Unquotes the given list expanding its arguments. Similar
to <a href="#unquote/1"><code class="inline">unquote/1</code></a></p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#with/1">with(args)</a>
  </div>
  
    <div class="summary-synopsis"><p>Used to combine matching clauses</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#%7B%7D/1">{args}</a>
  </div>
  
    <div class="summary-synopsis"><p>Creates a tuple</p>
</div>
  
</div>

  </div>


          

        </section>
      

      

      
        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <i class="icon-link"></i>
            </a>
            Functions
          </h1>
          <div class="detail" id="%25/2">
  
  <div class="detail-header">
    <a href="#%25/2" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">%</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L117" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Creates a struct.</p>
<p>A struct is a tagged map that allows developers to provide
default values for keys, tags to be used in polymorphic
dispatches and compile time assertions.</p>
<p>Structs are usually defined with the <a href="Kernel.html#defstruct/1"><code class="inline">Kernel.defstruct/1</code></a> macro:</p>
<pre><code class="elixir">defmodule User do
  defstruct name: &quot;john&quot;, age: 27
end</code></pre>
<p>Now a struct can be created as follows:</p>
<pre><code class="elixir">%User{}</code></pre>
<p>Underneath a struct is just a map with a <code class="inline">:__struct__</code> key
pointing to the <code class="inline">User</code> module:</p>
<pre><code class="elixir">%User{} == %{__struct__: User, name: &quot;john&quot;, age: 27}</code></pre>
<p>A struct also validates that the given keys are part of the defined
struct. The example below will fail because there is no key
<code class="inline">:full_name</code> in the <code class="inline">User</code> struct:</p>
<pre><code class="elixir">%User{full_name: &quot;john doe&quot;}</code></pre>
<p>An update operation specific for structs is also available:</p>
<pre><code class="elixir">%User{user | age: 28}</code></pre>
<p>The syntax above will guarantee the given keys are valid at
compilation time and it will guarantee at runtime the given
argument is a struct, failing with <a href="BadStructError.html"><code class="inline">BadStructError</code></a> otherwise.</p>
<p>Although structs are maps, by default structs do not implement
any of the protocols implemented for maps. Check
<a href="Kernel.html#defprotocol/2"><code class="inline">Kernel.defprotocol/2</code></a> for more information on how structs
can be used with protocols for polymorphic dispatch. Also
see <a href="Kernel.html#struct/2"><code class="inline">Kernel.struct/2</code></a> and <a href="Kernel.html#struct!/2"><code class="inline">Kernel.struct!/2</code></a> for examples on
how to create and update structs dynamically.</p>

  </section>
</div>
<div class="detail" id="%25%7B%7D/1">
  
  <div class="detail-header">
    <a href="#%25%7B%7D/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">%{}</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L72" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Creates a map.</p>
<p>See the <a href="Map.html"><code class="inline">Map</code></a> module for more information about maps, their syntax, and ways to
access and manipulate them.</p>
<h2 id="%25%7B%7D/1-ast-representation" class="section-heading">
  <a href="#%25%7B%7D/1-ast-representation" class="hover-link"><i class="icon-link"></i></a>
  AST representation
</h2>

<p>Regardless of whether <code class="inline">=&gt;</code> or the keyword syntax is used, key-value pairs in
maps are always represented internally as a list of two-element tuples for
simplicity:</p>
<pre><code class="iex elixir">iex&gt; quote do
...&gt;   %{&quot;a&quot; =&gt; :b, c: :d}
...&gt; end
{:%{}, [], [{&quot;a&quot;, :b}, {:c, :d}]}</code></pre>

  </section>
</div>
<div class="detail" id="&amp;/1">
  
  <div class="detail-header">
    <a href="#&amp;/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">&amp;(expr)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1450" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Captures or creates an anonymous function.</p>
<h2 id="&amp;/1-capture" class="section-heading">
  <a href="#&amp;/1-capture" class="hover-link"><i class="icon-link"></i></a>
  Capture
</h2>

<p>The capture operator is most commonly used to capture a
function with given name and arity from a module:</p>
<pre><code class="iex elixir">iex&gt; fun = &amp;Kernel.is_atom/1
iex&gt; fun.(:atom)
true
iex&gt; fun.(&quot;string&quot;)
false</code></pre>
<p>In the example above, we captured <a href="Kernel.html#is_atom/1"><code class="inline">Kernel.is_atom/1</code></a> as an
anonymous function and then invoked it.</p>
<p>The capture operator can also be used to capture local functions,
including private ones, and imported functions by omitting the
module name:</p>
<pre><code class="elixir">&amp;local_function/1</code></pre>
<h2 id="&amp;/1-anonymous-functions" class="section-heading">
  <a href="#&amp;/1-anonymous-functions" class="hover-link"><i class="icon-link"></i></a>
  Anonymous functions
</h2>

<p>The capture operator can also be used to partially apply
functions, where <code class="inline">&amp;1</code>, <code class="inline">&amp;2</code> and so on can be used as value
placeholders. For example:</p>
<pre><code class="iex elixir">iex&gt; double = &amp;(&amp;1 * 2)
iex&gt; double.(2)
4</code></pre>
<p>In other words, <code class="inline">&amp;(&amp;1 * 2)</code> is equivalent to <code class="inline">fn x -&gt; x * 2 end</code>.
Another example using a local function:</p>
<pre><code class="iex elixir">iex&gt; fun = &amp;is_atom(&amp;1)
iex&gt; fun.(:atom)
true</code></pre>
<p>The <code class="inline">&amp;</code> operator can be used with more complex expressions:</p>
<pre><code class="iex elixir">iex&gt; fun = &amp;(&amp;1 + &amp;2 + &amp;3)
iex&gt; fun.(1, 2, 3)
6</code></pre>
<p>As well as with lists and tuples:</p>
<pre><code class="iex elixir">iex&gt; fun = &amp;{&amp;1, &amp;2}
iex&gt; fun.(1, 2)
{1, 2}

iex&gt; fun = &amp;[&amp;1 | &amp;2]
iex&gt; fun.(1, 2)
[1 | 2]</code></pre>
<p>The only restrictions when creating anonymous functions is that at
least one placeholder must be present, i.e. it must contain at least
<code class="inline">&amp;1</code>, and that block expressions are not supported:</p>
<pre><code class="elixir"># No placeholder, fails to compile.
&amp;(:foo)

# Block expression, fails to compile.
&amp;(&amp;1; &amp;2)</code></pre>

  </section>
</div>
<div class="detail" id="./2">
  
  <div class="detail-header">
    <a href="#./2" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">left . right</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L425" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Defines a remote call or an alias.</p>
<p>The dot (<code class="inline">.</code>) in Elixir can be used for remote calls:</p>
<pre><code class="iex elixir">iex&gt; String.downcase(&quot;FOO&quot;)
&quot;foo&quot;</code></pre>
<p>In this example above, we have used <code class="inline">.</code> to invoke <code class="inline">downcase</code> in the
<a href="String.html"><code class="inline">String</code></a> alias, passing “FOO” as argument. We can also use the dot
for creating aliases:</p>
<pre><code class="iex elixir">iex&gt; Hello.World
Hello.World</code></pre>
<p>This time, we have joined two aliases, defining the final alias
<code class="inline">Hello.World</code>.</p>
<h2 id="./2-syntax" class="section-heading">
  <a href="#./2-syntax" class="hover-link"><i class="icon-link"></i></a>
  Syntax
</h2>

<p>The right side of <code class="inline">.</code> may be a word starting in upcase, which represents
an alias, a word starting with lowercase or underscore, any valid language
operator or any name wrapped in single- or double-quotes. Those are all valid
examples:</p>
<pre><code class="iex elixir">iex&gt; Kernel.Sample
Kernel.Sample

iex&gt; Kernel.length([1, 2, 3])
3

iex&gt; Kernel.+(1, 2)
3

iex&gt; Kernel.&quot;length&quot;([1, 2, 3])
3

iex&gt; Kernel.&#39;+&#39;(1, 2)
3</code></pre>
<p>Note that <code class="inline">Kernel.&quot;FUNCTION_NAME&quot;</code> will be treated as a remote call and not an alias.
This choice was done so every time single- or double-quotes are used, we have
a remote call regardless of the quote contents. This decision is also reflected
in the quoted expressions discussed below.</p>
<h2 id="./2-quoted-expression" class="section-heading">
  <a href="#./2-quoted-expression" class="hover-link"><i class="icon-link"></i></a>
  Quoted expression
</h2>

<p>When <code class="inline">.</code> is used, the quoted expression may take two distinct
forms. When the right side starts with a lowercase letter (or
underscore):</p>
<pre><code class="iex elixir">iex&gt; quote do
...&gt;   String.downcase(&quot;FOO&quot;)
...&gt; end
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [&quot;FOO&quot;]}</code></pre>
<p>Notice we have an inner tuple, containing the atom <code class="inline">:.</code> representing
the dot as first element:</p>
<pre><code class="elixir">{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}</code></pre>
<p>This tuple follows the general quoted expression structure in Elixir,
with the name as first argument, some keyword list as metadata as second,
and the number of arguments as third. In this case, the arguments is the
alias <a href="String.html"><code class="inline">String</code></a> and the atom <code class="inline">:downcase</code>. The second argument is <strong>always</strong>
an atom:</p>
<pre><code class="iex elixir">iex&gt; quote do
...&gt;   String.&quot;downcase&quot;(&quot;FOO&quot;)
...&gt; end
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [&quot;FOO&quot;]}</code></pre>
<p>The tuple containing <code class="inline">:.</code> is wrapped in another tuple, which actually
represents the function call, and has <code class="inline">&quot;FOO&quot;</code> as argument.</p>
<p>When the right side is an alias (i.e. starts with uppercase), we get instead:</p>
<pre><code class="iex elixir">iex&gt; quote do
...&gt;   Hello.World
...&gt; end
{:__aliases__, [alias: false], [:Hello, :World]}</code></pre>
<p>We go into more details about aliases in the <a href="#__aliases__/1"><code class="inline">__aliases__/1</code></a> special form
documentation.</p>
<h2 id="./2-unquoting" class="section-heading">
  <a href="#./2-unquoting" class="hover-link"><i class="icon-link"></i></a>
  Unquoting
</h2>

<p>We can also use unquote to generate a remote call in a quoted expression:</p>
<pre><code class="iex elixir">iex&gt; x = :downcase
iex&gt; quote do
...&gt;   String.unquote(x)(&quot;FOO&quot;)
...&gt; end
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [&quot;FOO&quot;]}</code></pre>
<p>Similar to <code class="inline">Kernel.&quot;FUNCTION_NAME&quot;</code>, <code class="inline">unquote(x)</code> will always generate a remote call,
independent of the value of <code class="inline">x</code>. To generate an alias via the quoted expression,
one needs to rely on <a href="Module.html#concat/2"><code class="inline">Module.concat/2</code></a>:</p>
<pre><code class="iex elixir">iex&gt; x = Sample
iex&gt; quote do
...&gt;   Module.concat(String, unquote(x))
...&gt; end
{{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],
 [{:__aliases__, [alias: false], [:String]}, Sample]}</code></pre>

  </section>
</div>
<div class="detail" id="::/2">
  
  <div class="detail-header">
    <a href="#::/2" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">left :: right</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L702" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Used by types and bitstrings to specify types.</p>
<p>This operator is used in two distinct occasions in Elixir.
It is used in typespecs to specify the type of a variable,
function or of a type itself:</p>
<pre><code class="elixir">@type number :: integer | float
@spec add(number, number) :: number</code></pre>
<p>It may also be used in bit strings to specify the type
of a given bit segment:</p>
<pre><code class="elixir">&lt;&lt;int::integer-little, rest::bits&gt;&gt; = bits</code></pre>
<p>Read the documentation on the <code class="inline">Typespec</code> page and
<a href="#%253C%253C%253E%253E/1"><code class="inline">&lt;&lt;&gt;&gt;/1</code></a> for more information on typespecs and
bitstrings respectively.</p>

  </section>
</div>
<div class="detail" id="%3C%3C%3E%3E/1">
  
  <div class="detail-header">
    <a href="#%3C%3C%3E%3E/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">&lt;&lt;args&gt;&gt;</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L316" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Defines a new bitstring.</p>
<h2 id="%3C%3C%3E%3E/1-examples" class="section-heading">
  <a href="#%3C%3C%3E%3E/1-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<pre><code class="iex elixir">iex&gt; &lt;&lt;1, 2, 3&gt;&gt;
&lt;&lt;1, 2, 3&gt;&gt;</code></pre>
<h2 id="%3C%3C%3E%3E/1-types" class="section-heading">
  <a href="#%3C%3C%3E%3E/1-types" class="hover-link"><i class="icon-link"></i></a>
  Types
</h2>

<p>A bitstring is made of many segments and each segment has a
type. There are 9 types used in bitstrings:</p>
<ul>
<li><code class="inline">integer</code>
</li>
<li><code class="inline">float</code>
</li>
<li><code class="inline">bits</code> (alias for <code class="inline">bitstring</code>)
</li>
<li><code class="inline">bitstring</code>
</li>
<li><code class="inline">binary</code>
</li>
<li><code class="inline">bytes</code> (alias for <code class="inline">binary</code>)
</li>
<li><code class="inline">utf8</code>
</li>
<li><code class="inline">utf16</code>
</li>
<li><code class="inline">utf32</code>
</li>
</ul>
<p>When no type is specified, the default is <code class="inline">integer</code>:</p>
<pre><code class="iex elixir">iex&gt; &lt;&lt;1, 2, 3&gt;&gt;
&lt;&lt;1, 2, 3&gt;&gt;</code></pre>
<p>Elixir also accepts by default the segment to be a literal
string or a literal charlist, which are by default expanded to integers:</p>
<pre><code class="iex elixir">iex&gt; &lt;&lt;0, &quot;foo&quot;&gt;&gt;
&lt;&lt;0, 102, 111, 111&gt;&gt;</code></pre>
<p>Variables or any other type need to be explicitly tagged:</p>
<pre><code class="iex elixir">iex&gt; rest = &quot;oo&quot;
iex&gt; &lt;&lt;102, rest&gt;&gt;
** (ArgumentError) argument error</code></pre>
<p>We can solve this by explicitly tagging it as <code class="inline">binary</code>:</p>
<pre><code class="iex elixir">iex&gt; rest = &quot;oo&quot;
iex&gt; &lt;&lt;102, rest::binary&gt;&gt;
&quot;foo&quot;</code></pre>
<p>The <code class="inline">utf8</code>, <code class="inline">utf16</code>, and <code class="inline">utf32</code> types are for Unicode codepoints. They
can also be applied to literal strings and charlists:</p>
<pre><code class="iex elixir">iex&gt; &lt;&lt;&quot;foo&quot;::utf16&gt;&gt;
&lt;&lt;0, 102, 0, 111, 0, 111&gt;&gt;
iex&gt; &lt;&lt;&quot;foo&quot;::utf32&gt;&gt;
&lt;&lt;0, 0, 0, 102, 0, 0, 0, 111, 0, 0, 0, 111&gt;&gt;</code></pre>
<h2 id="%3C%3C%3E%3E/1-options" class="section-heading">
  <a href="#%3C%3C%3E%3E/1-options" class="hover-link"><i class="icon-link"></i></a>
  Options
</h2>

<p>Many options can be given by using <code class="inline">-</code> as separator. Order is
arbitrary, so the following are all equivalent:</p>
<pre><code class="elixir">&lt;&lt;102::integer-native, rest::binary&gt;&gt;
&lt;&lt;102::native-integer, rest::binary&gt;&gt;
&lt;&lt;102::unsigned-big-integer, rest::binary&gt;&gt;
&lt;&lt;102::unsigned-big-integer-size(8), rest::binary&gt;&gt;
&lt;&lt;102::unsigned-big-integer-8, rest::binary&gt;&gt;
&lt;&lt;102::8-integer-big-unsigned, rest::binary&gt;&gt;
&lt;&lt;102, rest::binary&gt;&gt;</code></pre>
<h3>Unit and Size</h3>
<p>The length of the match is equal to the <code class="inline">unit</code> (a number of bits) times the
<code class="inline">size</code> (the number of repeated segments of length <code class="inline">unit</code>).</p>
<table>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th style="text-align: left">Type</th><th style="text-align: left">Default Unit</th>
</tr>
</thead>
<tr>
<td style="text-align: left"><code class="inline">integer</code></td><td style="text-align: left">1 bit</td>
</tr>
<tr>
<td style="text-align: left"><code class="inline">float</code></td><td style="text-align: left">1 bit</td>
</tr>
<tr>
<td style="text-align: left"><code class="inline">binary</code></td><td style="text-align: left">8 bits</td>
</tr>
</table>
<p>Sizes for types are a bit more nuanced. The default size for integers is 8.</p>
<p>For floats, it is 64. For floats, <code class="inline">size * unit</code> must result in 32 or 64,
corresponding to <a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754</a>
binary32 and binary64, respectively.</p>
<p>For binaries, the default is the size of the binary. Only the last binary in a
match can use the default size. All others must have their size specified
explicitly, even if the match is unambiguous. For example:</p>
<pre><code class="iex elixir">iex&gt; &lt;&lt;name::binary-size(5), &quot; the &quot;, species::binary&gt;&gt; = &lt;&lt;&quot;Frank the Walrus&quot;&gt;&gt;
&quot;Frank the Walrus&quot;
iex&gt; {name, species}
{&quot;Frank&quot;, &quot;Walrus&quot;}</code></pre>
<p>Failing to specify the size for the non-last causes compilation to fail:</p>
<pre><code class="elixir">&lt;&lt;name::binary, &quot; the &quot;, species::binary&gt;&gt; = &lt;&lt;&quot;Frank the Walrus&quot;&gt;&gt;
** (CompileError): a binary field without size is only allowed at the end of a binary pattern</code></pre>
<h4>Shortcut Syntax</h4>
<p>Size and unit can also be specified using a syntax shortcut
when passing integer values:</p>
<pre><code class="iex elixir">iex&gt; x = 1
iex&gt; &lt;&lt;x::8&gt;&gt; == &lt;&lt;x::size(8)&gt;&gt;
true
iex&gt; &lt;&lt;x::8*4&gt;&gt; == &lt;&lt;x::size(8)-unit(4)&gt;&gt;
true</code></pre>
<p>This syntax reflects the fact the effective size is given by
multiplying the size by the unit.</p>
<h3>Modifiers</h3>
<p>Some types have associated modifiers to clear up ambiguity in byte
representation.</p>
<table>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th style="text-align: left">Modifier</th><th style="text-align: left">Relevant Type(s)</th>
</tr>
</thead>
<tr>
<td style="text-align: left"><code class="inline">signed</code></td><td style="text-align: left"><code class="inline">integer</code></td>
</tr>
<tr>
<td style="text-align: left"><code class="inline">unsigned</code> (default)</td><td style="text-align: left"><code class="inline">integer</code></td>
</tr>
<tr>
<td style="text-align: left"><code class="inline">little</code></td><td style="text-align: left"><code class="inline">integer</code>, <code class="inline">float</code>, <code class="inline">utf16</code>, <code class="inline">utf32</code></td>
</tr>
<tr>
<td style="text-align: left"><code class="inline">big</code> (default)</td><td style="text-align: left"><code class="inline">integer</code>, <code class="inline">float</code>, <code class="inline">utf16</code>, <code class="inline">utf32</code></td>
</tr>
<tr>
<td style="text-align: left"><code class="inline">native</code></td><td style="text-align: left"><code class="inline">integer</code>, <code class="inline">utf16</code>, <code class="inline">utf32</code></td>
</tr>
</table>
<h3>Sign</h3>
<p>Integers can be <code class="inline">signed</code> or <code class="inline">unsigned</code>, defaulting to <code class="inline">unsigned</code>.</p>
<pre><code class="iex elixir">iex&gt; &lt;&lt;int::integer&gt;&gt; = &lt;&lt;-100&gt;&gt;
&lt;&lt;156&gt;&gt;
iex&gt; int
156
iex&gt; &lt;&lt;int::integer-signed&gt;&gt; = &lt;&lt;-100&gt;&gt;
&lt;&lt;156&gt;&gt;
iex&gt; int
-100</code></pre>
<p><code class="inline">signed</code> and <code class="inline">unsigned</code> are only used for matching binaries (see below) and
are only used for integers.</p>
<pre><code class="iex elixir">iex&gt; &lt;&lt;-100::signed, _rest::binary&gt;&gt; = &lt;&lt;-100, &quot;foo&quot;&gt;&gt;
&lt;&lt;156, 102, 111, 111&gt;&gt;</code></pre>
<h3>Endianness</h3>
<p>Elixir has three options for endianness: <code class="inline">big</code>, <code class="inline">little</code>, and <code class="inline">native</code>.
The default is <code class="inline">big</code>:</p>
<pre><code class="iex elixir">iex&gt; &lt;&lt;number::little-integer-size(16)&gt;&gt; = &lt;&lt;0, 1&gt;&gt;
&lt;&lt;0, 1&gt;&gt;
iex&gt; number
256
iex&gt; &lt;&lt;number::big-integer-size(16)&gt;&gt; = &lt;&lt;0, 1&gt;&gt;
&lt;&lt;0, 1&gt;&gt;
iex&gt; number
1</code></pre>
<p><code class="inline">native</code> is determined by the VM at startup and will depend on the
host operating system.</p>
<h2 id="%3C%3C%3E%3E/1-binary-bitstring-matching" class="section-heading">
  <a href="#%3C%3C%3E%3E/1-binary-bitstring-matching" class="hover-link"><i class="icon-link"></i></a>
  Binary/Bitstring Matching
</h2>

<p>Binary matching is a powerful feature in Elixir that is useful for extracting
information from binaries as well as pattern matching.</p>
<p>Binary matching can be used by itself to extract information from binaries:</p>
<pre><code class="iex elixir">iex&gt; &lt;&lt;&quot;Hello, &quot;, place::binary&gt;&gt; = &quot;Hello, World&quot;
&quot;Hello, World&quot;
iex&gt; place
&quot;World&quot;</code></pre>
<p>Or as a part of function definitions to pattern match:</p>
<pre><code class="elixir">defmodule ImageTyper
  @png_signature &lt;&lt;137::size(8), 80::size(8), 78::size(8), 71::size(8),
                   13::size(8), 10::size(8), 26::size(8), 10::size(8)&gt;&gt;
  @jpg_signature &lt;&lt;255::size(8), 216::size(8)&gt;&gt;

  def type(&lt;&lt;@png_signature, rest::binary&gt;&gt;), do: :png
  def type(&lt;&lt;@jpg_signature, rest::binary&gt;&gt;), do: :jpg
  def type(_), do :unknown
end</code></pre>
<h3>Performance &amp; Optimizations</h3>
<p>The Erlang compiler can provide a number of optimizations on binary creation
and matching. To see optimization output, set the <code class="inline">bin_opt_info</code> compiler
option:</p>
<pre><code class="elixir">ERL_COMPILER_OPTIONS=bin_opt_info mix compile</code></pre>
<p>To learn more about specific optimizations and performance considerations,
check out
<a href="http://www.erlang.org/doc/efficiency_guide/binaryhandling.html">Erlang’s Efficiency Guide on handling binaries</a>.</p>

  </section>
</div>
<div class="detail" id="=/2">
  
  <div class="detail-header">
    <a href="#=/2" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">left = right</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L681" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Matches the value on the right against the pattern on the left.</p>

  </section>
</div>
<div class="detail" id="%5E/1">
  
  <div class="detail-header">
    <a href="#%5E/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">^var</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L676" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Accesses an already bound variable in match clauses. Also known as the pin operator.</p>
<h2 id="%5E/1-examples" class="section-heading">
  <a href="#%5E/1-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<p>Elixir allows variables to be rebound via static single assignment:</p>
<pre><code class="iex elixir">iex&gt; x = 1
iex&gt; x = x + 1
iex&gt; x
2</code></pre>
<p>However, in some situations, it is useful to match against an existing
value, instead of rebinding. This can be done with the <code class="inline">^</code> special form,
colloquially known as the pin operator:</p>
<pre><code class="iex elixir">iex&gt; x = 1
iex&gt; ^x = List.first([1])
iex&gt; ^x = List.first([2])
** (MatchError) no match of right hand side value: 2</code></pre>
<p>Note that <code class="inline">^x</code> always refers to the value of <code class="inline">x</code> prior to the match. The
following example will match:</p>
<pre><code class="iex elixir">iex&gt; x = 0
iex&gt; {x, ^x} = {1, 0}
iex&gt; x
1</code></pre>

  </section>
</div>
<div class="detail" id="__CALLER__/0">
  
  <div class="detail-header">
    <a href="#__CALLER__/0" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">__CALLER__</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L644" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Returns the current calling environment as a <a href="Macro.Env.html"><code class="inline">Macro.Env</code></a> struct.</p>
<p>In the environment you can access the filename, line numbers,
set up aliases, the function and others.</p>

  </section>
</div>
<div class="detail" id="__DIR__/0">
  
  <div class="detail-header">
    <a href="#__DIR__/0" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">__DIR__</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L636" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Returns the absolute path of the directory of the current file as a binary.</p>
<p>Although the directory can be accessed as <code class="inline">Path.dirname(__ENV__.file)</code>,
this macro is a convenient shortcut.</p>

  </section>
</div>
<div class="detail" id="__ENV__/0">
  
  <div class="detail-header">
    <a href="#__ENV__/0" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">__ENV__</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L620" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Returns the current environment information as a <a href="Macro.Env.html"><code class="inline">Macro.Env</code></a> struct.</p>
<p>In the environment you can access the current filename,
line numbers, set up aliases, the current function and others.</p>

  </section>
</div>
<div class="detail" id="__MODULE__/0">
  
  <div class="detail-header">
    <a href="#__MODULE__/0" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">__MODULE__</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L628" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Returns the current module name as an atom or <code class="inline">nil</code> otherwise.</p>
<p>Although the module can be accessed in the <a href="#__ENV__/0"><code class="inline">__ENV__/0</code></a>, this macro
is a convenient shortcut.</p>

  </section>
</div>
<div class="detail" id="__aliases__/1">
  
  <div class="detail-header">
    <a href="#__aliases__/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">__aliases__(args)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1484" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Internal special form to hold aliases information.</p>
<p>It is usually compiled to an atom:</p>
<pre><code class="iex elixir">iex&gt; quote do
...&gt;   Foo.Bar
...&gt; end
{:__aliases__, [alias: false], [:Foo, :Bar]}</code></pre>
<p>Elixir represents <code class="inline">Foo.Bar</code> as <code class="inline">__aliases__</code> so calls can be
unambiguously identified by the operator <code class="inline">:.</code>. For example:</p>
<pre><code class="iex elixir">iex&gt; quote do
...&gt;   Foo.bar
...&gt; end
{{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}</code></pre>
<p>Whenever an expression iterator sees a <code class="inline">:.</code> as the tuple key,
it can be sure that it represents a call and the second argument
in the list is an atom.</p>
<p>On the other hand, aliases holds some properties:</p>
<ol>
<li><p>The head element of aliases can be any term that must expand to
 an atom at compilation time.</p>
</li>
<li><p>The tail elements of aliases are guaranteed to always be atoms.</p>
</li>
<li><p>When the head element of aliases is the atom <code class="inline">:Elixir</code>, no expansion happens.</p>
</li>
</ol>

  </section>
</div>
<div class="detail" id="__block__/1">
  
  <div class="detail-header">
    <a href="#__block__/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">__block__(args)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1381" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Internal special form for block expressions.</p>
<p>This is the special form used whenever we have a block
of expressions in Elixir. This special form is private
and should not be invoked directly:</p>
<pre><code class="iex elixir">iex&gt; quote do
...&gt;   1
...&gt;   2
...&gt;   3
...&gt; end
{:__block__, [], [1, 2, 3]}</code></pre>

  </section>
</div>
<div class="detail" id="alias/2">
  
  <div class="detail-header">
    <a href="#alias/2" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">alias(module, opts)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L485" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p><a href="#alias/2"><code class="inline">alias/2</code></a> is used to setup aliases, often useful with modules names.</p>
<h2 id="alias/2-examples" class="section-heading">
  <a href="#alias/2-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<p><a href="#alias/2"><code class="inline">alias/2</code></a> can be used to setup an alias for any module:</p>
<pre><code class="elixir">defmodule Math do
  alias MyKeyword, as: Keyword
end</code></pre>
<p>In the example above, we have set up <code class="inline">MyKeyword</code> to be aliased
as <a href="Keyword.html"><code class="inline">Keyword</code></a>. So now, any reference to <a href="Keyword.html"><code class="inline">Keyword</code></a> will be
automatically replaced by <code class="inline">MyKeyword</code>.</p>
<p>In case one wants to access the original <a href="Keyword.html"><code class="inline">Keyword</code></a>, it can be done
by accessing <code class="inline">Elixir</code>:</p>
<pre><code class="elixir">Keyword.values   #=&gt; uses MyKeyword.values
Elixir.Keyword.values #=&gt; uses Keyword.values</code></pre>
<p>Notice that calling <code class="inline">alias</code> without the <code class="inline">as:</code> option automatically
sets an alias based on the last part of the module. For example:</p>
<pre><code class="elixir">alias Foo.Bar.Baz</code></pre>
<p>Is the same as:</p>
<pre><code class="elixir">alias Foo.Bar.Baz, as: Baz</code></pre>
<p>We can also alias multiple modules in one line:</p>
<pre><code class="elixir">alias Foo.{Bar, Baz, Biz}</code></pre>
<p>Is the same as:</p>
<pre><code class="elixir">alias Foo.Bar
alias Foo.Baz
alias Foo.Biz</code></pre>
<h2 id="alias/2-lexical-scope" class="section-heading">
  <a href="#alias/2-lexical-scope" class="hover-link"><i class="icon-link"></i></a>
  Lexical scope
</h2>

<p><a href="#import/2"><code class="inline">import/2</code></a>, <a href="#require/2"><code class="inline">require/2</code></a> and <a href="#alias/2"><code class="inline">alias/2</code></a> are called directives and all
have lexical scope. This means you can set up aliases inside
specific functions and it won’t affect the overall scope.</p>
<h2 id="alias/2-warnings" class="section-heading">
  <a href="#alias/2-warnings" class="hover-link"><i class="icon-link"></i></a>
  Warnings
</h2>

<p>If you alias a module and you don’t use the alias, Elixir is
going to issue a warning implying the alias is not being used.</p>
<p>In case the alias is generated automatically by a macro,
Elixir won’t emit any warnings though, since the alias
was not explicitly defined.</p>
<p>Both warning behaviours could be changed by explicitly
setting the <code class="inline">:warn</code> option to <code class="inline">true</code> or <code class="inline">false</code>.</p>

  </section>
</div>
<div class="detail" id="case/2">
  
  <div class="detail-header">
    <a href="#case/2" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">case(condition, clauses)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1564" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Matches the given expression against the given clauses.</p>
<h2 id="case/2-examples" class="section-heading">
  <a href="#case/2-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<pre><code class="elixir">case thing do
  {:selector, i, value} when is_integer(i) -&gt;
    value
  value -&gt;
    value
end</code></pre>
<p>In the example above, we match <code class="inline">thing</code> against each clause “head”
and execute the clause “body” corresponding to the first clause
that matches.</p>
<p>If no clause matches, an error is raised.
For this reason, it may be necessary to add a final catch-all clause (like <code class="inline">_</code>)
which will always match.</p>
<pre><code class="elixir">x = 10

case x do
  0 -&gt;
    &quot;This clause won&#39;t match&quot;
  _ -&gt;
    &quot;This clause would match any value (x = #{x})&quot;
end
#=&gt; &quot;This clause would match any value (x = 10)&quot;</code></pre>
<h2 id="case/2-variables-handling" class="section-heading">
  <a href="#case/2-variables-handling" class="hover-link"><i class="icon-link"></i></a>
  Variables handling
</h2>

<p>Notice that variables bound in a clause “head” do not leak to the
outer context:</p>
<pre><code class="elixir">case data do
  {:ok, value} -&gt; value
  :error -&gt; nil
end

value #=&gt; unbound variable value</code></pre>
<p>However, variables explicitly bound in the clause “body” are
accessible from the outer context:</p>
<pre><code class="elixir">value = 7

case lucky? do
  false -&gt; value = 13
  true  -&gt; true
end

value #=&gt; 7 or 13</code></pre>
<p>In the example above, value is going to be <code class="inline">7</code> or <code class="inline">13</code> depending on
the value of <code class="inline">lucky?</code>. In case <code class="inline">value</code> has no previous value before
case, clauses that do not explicitly bind a value have the variable
bound to <code class="inline">nil</code>.</p>
<p>If you want to pattern match against an existing variable,
you need to use the <a href="#%255E/1"><code class="inline">^/1</code></a> operator:</p>
<pre><code class="elixir">x = 1

case 10 do
  ^x -&gt; &quot;Won&#39;t match&quot;
  _  -&gt; &quot;Will match&quot;
end
#=&gt; &quot;Will match&quot;</code></pre>

  </section>
</div>
<div class="detail" id="cond/1">
  
  <div class="detail-header">
    <a href="#cond/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">cond(clauses)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1593" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Evaluates the expression corresponding to the first clause that
evaluates to a truthy value.</p>
<pre><code class="elixir">cond do
  hd([1, 2, 3]) -&gt;
    &quot;1 is considered as true&quot;
end
#=&gt; &quot;1 is considered as true&quot;</code></pre>
<p>Raises an error if all conditions evaluate to <code class="inline">nil</code> or <code class="inline">false</code>.
For this reason, it may be necessary to add a final always-truthy condition
(anything non-<code class="inline">false</code> and non-<code class="inline">nil</code>), which will always match.</p>
<h2 id="cond/1-examples" class="section-heading">
  <a href="#cond/1-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<pre><code class="elixir">cond do
  1 + 1 == 1 -&gt;
    &quot;This will never match&quot;
  2 * 2 != 4 -&gt;
    &quot;Nor this&quot;
  true -&gt;
    &quot;This will&quot;
end
#=&gt; &quot;This will&quot;</code></pre>

  </section>
</div>
<div class="detail" id="fn/1">
  
  <div class="detail-header">
    <a href="#fn/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">fn
  [clauses]
end</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1364" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Defines an anonymous function.</p>
<h2 id="fn/1-examples" class="section-heading">
  <a href="#fn/1-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<pre><code class="iex elixir">iex&gt; add = fn a, b -&gt; a + b end
iex&gt; add.(1, 2)
3</code></pre>

  </section>
</div>
<div class="detail" id="for/1">
  
  <div class="detail-header">
    <a href="#for/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">for(args)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1294" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Comprehensions allow you to quickly build a data structure from
an enumerable or a bitstring.</p>
<p>Let’s start with an example:</p>
<pre><code class="iex elixir">iex&gt; for n &lt;- [1, 2, 3, 4], do: n * 2
[2, 4, 6, 8]</code></pre>
<p>A comprehension accepts many generators and filters. Enumerable
generators are defined using <code class="inline">&lt;-</code>:</p>
<pre><code class="elixir"># A list generator:
iex&gt; for n &lt;- [1, 2, 3, 4], do: n * 2
[2, 4, 6, 8]

# A comprehension with two generators
iex&gt; for x &lt;- [1, 2], y &lt;- [2, 3], do: x * y
[2, 3, 4, 6]</code></pre>
<p>Filters can also be given:</p>
<pre><code class="elixir"># A comprehension with a generator and a filter
iex&gt; for n &lt;- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n
[2, 4, 6]</code></pre>
<p>Note generators can also be used to filter as it removes any value
that doesn’t match the pattern on the left side of <code class="inline">&lt;-</code>:</p>
<pre><code class="iex elixir">iex&gt; users = [user: &quot;john&quot;, admin: &quot;meg&quot;, guest: &quot;barbara&quot;]
iex&gt; for {type, name} when type != :guest &lt;- users do
...&gt;   String.upcase(name)
...&gt; end
[&quot;JOHN&quot;, &quot;MEG&quot;]</code></pre>
<p>Bitstring generators are also supported and are very useful when you
need to organize bitstring streams:</p>
<pre><code class="iex elixir">iex&gt; pixels = &lt;&lt;213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15&gt;&gt;
iex&gt; for &lt;&lt;r::8, g::8, b::8 &lt;- pixels&gt;&gt;, do: {r, g, b}
[{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]</code></pre>
<p>Variable assignments inside the comprehension, be it in generators,
filters or inside the block, are not reflected outside of the
comprehension.</p>
<h2 id="for/1-into" class="section-heading">
  <a href="#for/1-into" class="hover-link"><i class="icon-link"></i></a>
  Into
</h2>

<p>In the examples above, the result returned by the comprehension was
always a list. The returned result can be configured by passing an
<code class="inline">:into</code> option, that accepts any structure as long as it implements
the <a href="Collectable.html"><code class="inline">Collectable</code></a> protocol.</p>
<p>For example, we can use bitstring generators with the <code class="inline">:into</code> option
to easily remove all spaces in a string:</p>
<pre><code class="iex elixir">iex&gt; for &lt;&lt;c &lt;- &quot; hello world &quot;&gt;&gt;, c != ?\s, into: &quot;&quot;, do: &lt;&lt;c&gt;&gt;
&quot;helloworld&quot;</code></pre>
<p>The <a href="IO.html"><code class="inline">IO</code></a> module provides streams, that are both <a href="Enumerable.html"><code class="inline">Enumerable</code></a> and
<a href="Collectable.html"><code class="inline">Collectable</code></a>, here is an upcase echo server using comprehensions:</p>
<pre><code class="elixir">for line &lt;- IO.stream(:stdio, :line), into: IO.stream(:stdio, :line) do
  String.upcase(line)
end</code></pre>

  </section>
</div>
<div class="detail" id="import/2">
  
  <div class="detail-header">
    <a href="#import/2" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">import(module, opts)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L612" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Imports functions and macros from other modules.</p>
<p><a href="#import/2"><code class="inline">import/2</code></a> allows one to easily access functions or macros from
others modules without using the qualified name.</p>
<h2 id="import/2-examples" class="section-heading">
  <a href="#import/2-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<p>If you are using several functions from a given module, you can
import those functions and reference them as local functions,
for example:</p>
<pre><code class="iex elixir">iex&gt; import List
iex&gt; flatten([1, [2], 3])
[1, 2, 3]</code></pre>
<h2 id="import/2-selector" class="section-heading">
  <a href="#import/2-selector" class="hover-link"><i class="icon-link"></i></a>
  Selector
</h2>

<p>By default, Elixir imports functions and macros from the given
module, except the ones starting with underscore (which are
usually callbacks):</p>
<pre><code class="elixir">import List</code></pre>
<p>A developer can filter to import only macros or functions via
the only option:</p>
<pre><code class="elixir">import List, only: :functions
import List, only: :macros</code></pre>
<p>Alternatively, Elixir allows a developer to pass pairs of
name/arities to <code class="inline">:only</code> or <code class="inline">:except</code> as a fine grained control
on what to import (or not):</p>
<pre><code class="elixir">import List, only: [flatten: 1]
import String, except: [split: 2]</code></pre>
<p>Notice that calling <code class="inline">except</code> for a previously declared <a href="#import/2"><code class="inline">import/2</code></a>
simply filters the previously imported elements. For example:</p>
<pre><code class="elixir">import List, only: [flatten: 1, keyfind: 4]
import List, except: [flatten: 1]</code></pre>
<p>After the two import calls above, only <a href="List.html#keyfind/4"><code class="inline">List.keyfind/4</code></a> will be
imported.</p>
<h2 id="import/2-underscore-functions" class="section-heading">
  <a href="#import/2-underscore-functions" class="hover-link"><i class="icon-link"></i></a>
  Underscore functions
</h2>

<p>By default functions starting with <code class="inline">_</code> are not imported. If you really want
to import a function starting with <code class="inline">_</code> you must explicitly include it in the
<code class="inline">:only</code> selector.</p>
<pre><code class="elixir">import File.Stream, only: [__build__: 3]</code></pre>
<h2 id="import/2-lexical-scope" class="section-heading">
  <a href="#import/2-lexical-scope" class="hover-link"><i class="icon-link"></i></a>
  Lexical scope
</h2>

<p>It is important to notice that <a href="#import/2"><code class="inline">import/2</code></a> is lexical. This means you
can import specific macros inside specific functions:</p>
<pre><code class="elixir">defmodule Math do
  def some_function do
    # 1) Disable &quot;if/2&quot; from Kernel
    import Kernel, except: [if: 2]

    # 2) Require the new &quot;if/2&quot; macro from MyMacros
    import MyMacros

    # 3) Use the new macro
    if do_something, it_works
  end
end</code></pre>
<p>In the example above, we imported macros from <code class="inline">MyMacros</code>,
replacing the original <code class="inline">if/2</code> implementation by our own
within that specific function. All other functions in that
module will still be able to use the original one.</p>
<h2 id="import/2-warnings" class="section-heading">
  <a href="#import/2-warnings" class="hover-link"><i class="icon-link"></i></a>
  Warnings
</h2>

<p>If you import a module and you don’t use any of the imported
functions or macros from this module, Elixir is going to issue
a warning implying the import is not being used.</p>
<p>In case the import is generated automatically by a macro,
Elixir won’t emit any warnings though, since the import
was not explicitly defined.</p>
<p>Both warning behaviours could be changed by explicitly
setting the <code class="inline">:warn</code> option to <code class="inline">true</code> or <code class="inline">false</code>.</p>
<h2 id="import/2-ambiguous-function-macro-names" class="section-heading">
  <a href="#import/2-ambiguous-function-macro-names" class="hover-link"><i class="icon-link"></i></a>
  Ambiguous function/macro names
</h2>

<p>If two modules <code class="inline">A</code> and <code class="inline">B</code> are imported and they both contain
a <code class="inline">foo</code> function with an arity of <code class="inline">1</code>, an error is only emitted
if an ambiguous call to <code class="inline">foo/1</code> is actually made; that is, the
errors are emitted lazily, not eagerly.</p>

  </section>
</div>
<div class="detail" id="quote/2">
  
  <div class="detail-header">
    <a href="#quote/2" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">quote(opts, block)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1181" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Gets the representation of any expression.</p>
<h2 id="quote/2-examples" class="section-heading">
  <a href="#quote/2-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<pre><code class="iex elixir">iex&gt; quote do
...&gt;   sum(1, 2, 3)
...&gt; end
{:sum, [], [1, 2, 3]}</code></pre>
<h2 id="quote/2-explanation" class="section-heading">
  <a href="#quote/2-explanation" class="hover-link"><i class="icon-link"></i></a>
  Explanation
</h2>

<p>Any Elixir code can be represented using Elixir data structures.
The building block of Elixir macros is a tuple with three elements,
for example:</p>
<pre><code class="elixir">{:sum, [], [1, 2, 3]}</code></pre>
<p>The tuple above represents a function call to <code class="inline">sum</code> passing 1, 2 and
3 as arguments. The tuple elements are:</p>
<ul>
<li><p>The first element of the tuple is always an atom or
another tuple in the same representation.</p>
</li>
<li><p>The second element of the tuple represents metadata.</p>
</li>
<li><p>The third element of the tuple are the arguments for the
function call. The third argument may be an atom, which is
usually a variable (or a local call).</p>
</li>
</ul>
<h2 id="quote/2-options" class="section-heading">
  <a href="#quote/2-options" class="hover-link"><i class="icon-link"></i></a>
  Options
</h2>

<ul>
<li><p><code class="inline">:unquote</code> - when <code class="inline">false</code>, disables unquoting. Useful when you have a quote
inside another quote and want to control what quote is able to unquote.</p>
</li>
<li><p><code class="inline">:location</code> - when set to <code class="inline">:keep</code>, keeps the current line and file from
quote. Read the Stacktrace information section below for more
information.</p>
</li>
<li><p><code class="inline">:generated</code> - marks the given chunk as generated so it does not emit warnings.
Currently it only works on special forms (for example, you can annotate a <code class="inline">case</code>
but not an <code class="inline">if</code>).</p>
</li>
<li><p><code class="inline">:context</code> - sets the resolution context.</p>
</li>
<li><p><code class="inline">:bind_quoted</code> - passes a binding to the macro. Whenever a binding is
given, <a href="#unquote/1"><code class="inline">unquote/1</code></a> is automatically disabled.</p>
</li>
</ul>
<h2 id="quote/2-quote-literals" class="section-heading">
  <a href="#quote/2-quote-literals" class="hover-link"><i class="icon-link"></i></a>
  Quote literals
</h2>

<p>Besides the tuple described above, Elixir has a few literals that
when quoted return themselves. They are:</p>
<pre><code class="elixir">:sum         #=&gt; Atoms
1            #=&gt; Integers
2.0          #=&gt; Floats
[1, 2]       #=&gt; Lists
&quot;strings&quot;    #=&gt; Strings
{key, value} #=&gt; Tuples with two elements</code></pre>
<h2 id="quote/2-quote-and-macros" class="section-heading">
  <a href="#quote/2-quote-and-macros" class="hover-link"><i class="icon-link"></i></a>
  Quote and macros
</h2>

<p><a href="#quote/2"><code class="inline">quote/2</code></a> is commonly used with macros for code generation. As an exercise,
let’s define a macro that multiplies a number by itself (squared). Note
there is no reason to define such as a macro (and it would actually be
seen as a bad practice), but it is simple enough that it allows us to focus
on the important aspects of quotes and macros:</p>
<pre><code class="elixir">defmodule Math do
  defmacro squared(x) do
    quote do
      unquote(x) * unquote(x)
    end
  end
end</code></pre>
<p>We can invoke it as:</p>
<pre><code class="elixir">import Math
IO.puts &quot;Got #{squared(5)}&quot;</code></pre>
<p>At first, there is nothing in this example that actually reveals it is a
macro. But what is happening is that, at compilation time, <code class="inline">squared(5)</code>
becomes <code class="inline">5 * 5</code>. The argument <code class="inline">5</code> is duplicated in the produced code, we
can see this behaviour in practice though because our macro actually has
a bug:</p>
<pre><code class="elixir">import Math
my_number = fn -&gt;
  IO.puts &quot;Returning 5&quot;
  5
end
IO.puts &quot;Got #{squared(my_number.())}&quot;</code></pre>
<p>The example above will print:</p>
<pre><code class="elixir">Returning 5
Returning 5
Got 25</code></pre>
<p>Notice how “Returning 5” was printed twice, instead of just once. This is
because a macro receives an expression and not a value (which is what we
would expect in a regular function). This means that:</p>
<pre><code class="elixir">squared(my_number.())</code></pre>
<p>Actually expands to:</p>
<pre><code class="elixir">my_number.() * my_number.()</code></pre>
<p>Which invokes the function twice, explaining why we get the printed value
twice! In the majority of the cases, this is actually unexpected behaviour,
and that’s why one of the first things you need to keep in mind when it
comes to macros is to <strong>not unquote the same value more than once</strong>.</p>
<p>Let’s fix our macro:</p>
<pre><code class="elixir">defmodule Math do
  defmacro squared(x) do
    quote do
      x = unquote(x)
      x * x
    end
  end
end</code></pre>
<p>Now invoking <code class="inline">square(my_number.())</code> as before will print the value just
once.</p>
<p>In fact, this pattern is so common that most of the times you will want
to use the <code class="inline">bind_quoted</code> option with <a href="#quote/2"><code class="inline">quote/2</code></a>:</p>
<pre><code class="elixir">defmodule Math do
  defmacro squared(x) do
    quote bind_quoted: [x: x] do
      x * x
    end
  end
end</code></pre>
<p><code class="inline">:bind_quoted</code> will translate to the same code as the example above.
<code class="inline">:bind_quoted</code> can be used in many cases and is seen as good practice,
not only because it helps us from running into common mistakes but also
because it allows us to leverage other tools exposed by macros, such as
unquote fragments discussed in some sections below.</p>
<p>Before we finish this brief introduction, you will notice that, even though
we defined a variable <code class="inline">x</code> inside our quote:</p>
<pre><code class="elixir">quote do
  x = unquote(x)
  x * x
end</code></pre>
<p>When we call:</p>
<pre><code class="elixir">import Math
squared(5)
x #=&gt; ** (CompileError) undefined variable x or undefined function x/0</code></pre>
<p>We can see that <code class="inline">x</code> did not leak to the user context. This happens
because Elixir macros are hygienic, a topic we will discuss at length
in the next sections as well.</p>
<h2 id="quote/2-hygiene-in-variables" class="section-heading">
  <a href="#quote/2-hygiene-in-variables" class="hover-link"><i class="icon-link"></i></a>
  Hygiene in variables
</h2>

<p>Consider the following example:</p>
<pre><code class="elixir">defmodule Hygiene do
  defmacro no_interference do
    quote do
      a = 1
    end
  end
end

require Hygiene

a = 10
Hygiene.no_interference
a #=&gt; 10</code></pre>
<p>In the example above, <code class="inline">a</code> returns 10 even if the macro
is apparently setting it to 1 because variables defined
in the macro do not affect the context the macro is executed in.
If you want to set or get a variable in the caller’s context, you
can do it with the help of the <code class="inline">var!</code> macro:</p>
<pre><code class="elixir">defmodule NoHygiene do
  defmacro interference do
    quote do
      var!(a) = 1
    end
  end
end

require NoHygiene

a = 10
NoHygiene.interference
a #=&gt; 1</code></pre>
<p>Note that you cannot even access variables defined in the same
module unless you explicitly give it a context:</p>
<pre><code class="elixir">defmodule Hygiene do
  defmacro write do
    quote do
      a = 1
    end
  end

  defmacro read do
    quote do
      a
    end
  end
end

Hygiene.write
Hygiene.read
#=&gt; ** (RuntimeError) undefined variable a or undefined function a/0</code></pre>
<p>For such, you can explicitly pass the current module scope as
argument:</p>
<pre><code class="elixir">defmodule ContextHygiene do
  defmacro write do
    quote do
      var!(a, ContextHygiene) = 1
    end
  end

  defmacro read do
    quote do
      var!(a, ContextHygiene)
    end
  end
end

ContextHygiene.write
ContextHygiene.read
#=&gt; 1</code></pre>
<h2 id="quote/2-hygiene-in-aliases" class="section-heading">
  <a href="#quote/2-hygiene-in-aliases" class="hover-link"><i class="icon-link"></i></a>
  Hygiene in aliases
</h2>

<p>Aliases inside quote are hygienic by default.
Consider the following example:</p>
<pre><code class="elixir">defmodule Hygiene do
  alias Map, as: M

  defmacro no_interference do
    quote do
      M.new
    end
  end
end

require Hygiene
Hygiene.no_interference #=&gt; %{}</code></pre>
<p>Notice that, even though the alias <code class="inline">M</code> is not available
in the context the macro is expanded, the code above works
because <code class="inline">M</code> still expands to <a href="Map.html"><code class="inline">Map</code></a>.</p>
<p>Similarly, even if we defined an alias with the same name
before invoking a macro, it won’t affect the macro’s result:</p>
<pre><code class="elixir">defmodule Hygiene do
  alias Map, as: M

  defmacro no_interference do
    quote do
      M.new
    end
  end
end

require Hygiene
alias SomethingElse, as: M
Hygiene.no_interference #=&gt; %{}</code></pre>
<p>In some cases, you want to access an alias or a module defined
in the caller. For such, you can use the <code class="inline">alias!</code> macro:</p>
<pre><code class="elixir">defmodule Hygiene do
  # This will expand to Elixir.Nested.hello
  defmacro no_interference do
    quote do
      Nested.hello
    end
  end

  # This will expand to Nested.hello for
  # whatever is Nested in the caller
  defmacro interference do
    quote do
      alias!(Nested).hello
    end
  end
end

defmodule Parent do
  defmodule Nested do
    def hello, do: &quot;world&quot;
  end

  require Hygiene
  Hygiene.no_interference
  #=&gt; ** (UndefinedFunctionError) ...

  Hygiene.interference
  #=&gt; &quot;world&quot;
end</code></pre>
<h2 id="quote/2-hygiene-in-imports" class="section-heading">
  <a href="#quote/2-hygiene-in-imports" class="hover-link"><i class="icon-link"></i></a>
  Hygiene in imports
</h2>

<p>Similar to aliases, imports in Elixir are hygienic. Consider the
following code:</p>
<pre><code class="elixir">defmodule Hygiene do
  defmacrop get_length do
    quote do
      length([1, 2, 3])
    end
  end

  def return_length do
    import Kernel, except: [length: 1]
    get_length
  end
end

Hygiene.return_length #=&gt; 3</code></pre>
<p>Notice how <code class="inline">Hygiene.return_length/0</code> returns <code class="inline">3</code> even though the <a href="Kernel.html#length/1"><code class="inline">Kernel.length/1</code></a>
function is not imported. In fact, even if <code class="inline">return_length/0</code>
imported a function with the same name and arity from another
module, it wouldn’t affect the function result:</p>
<pre><code class="elixir">def return_length do
  import String, only: [length: 1]
  get_length
end</code></pre>
<p>Calling this new <code class="inline">return_length/0</code> will still return <code class="inline">3</code> as result.</p>
<p>Elixir is smart enough to delay the resolution to the latest
possible moment. So, if you call <code class="inline">length([1, 2, 3])</code> inside quote,
but no <code class="inline">length/1</code> function is available, it is then expanded in
the caller:</p>
<pre><code class="elixir">defmodule Lazy do
  defmacrop get_length do
    import Kernel, except: [length: 1]

    quote do
      length(&quot;hello&quot;)
    end
  end

  def return_length do
    import Kernel, except: [length: 1]
    import String, only: [length: 1]
    get_length
  end
end

Lazy.return_length #=&gt; 5</code></pre>
<h2 id="quote/2-stacktrace-information" class="section-heading">
  <a href="#quote/2-stacktrace-information" class="hover-link"><i class="icon-link"></i></a>
  Stacktrace information
</h2>

<p>When defining functions via macros, developers have the option of
choosing if runtime errors will be reported from the caller or from
inside the quote. Let’s see an example:</p>
<pre><code class="elixir"># adder.ex
defmodule Adder do
  @doc &quot;Defines a function that adds two numbers&quot;
  defmacro defadd do
    quote location: :keep do
      def add(a, b), do: a + b
    end
  end
end

# sample.ex
defmodule Sample do
  import Adder
  defadd
end

require Sample
Sample.add(:one, :two)
#=&gt; ** (ArithmeticError) bad argument in arithmetic expression
#=&gt;     adder.ex:5: Sample.add/2</code></pre>
<p>When using <code class="inline">location: :keep</code> and invalid arguments are given to
<code class="inline">Sample.add/2</code>, the stacktrace information will point to the file
and line inside the quote. Without <code class="inline">location: :keep</code>, the error is
reported to where <code class="inline">defadd</code> was invoked. Note <code class="inline">location: :keep</code> affects
only definitions inside the quote.</p>
<h2 id="quote/2-binding-and-unquote-fragments" class="section-heading">
  <a href="#quote/2-binding-and-unquote-fragments" class="hover-link"><i class="icon-link"></i></a>
  Binding and unquote fragments
</h2>

<p>Elixir quote/unquote mechanisms provides a functionality called
unquote fragments. Unquote fragments provide an easy way to generate
functions on the fly. Consider this example:</p>
<pre><code class="elixir">kv = [foo: 1, bar: 2]
Enum.each kv, fn {k, v} -&gt;
  def unquote(k)(), do: unquote(v)
end</code></pre>
<p>In the example above, we have generated the functions <code class="inline">foo/0</code> and
<code class="inline">bar/0</code> dynamically. Now, imagine that, we want to convert this
functionality into a macro:</p>
<pre><code class="elixir">defmacro defkv(kv) do
  Enum.map kv, fn {k, v} -&gt;
    quote do
      def unquote(k)(), do: unquote(v)
    end
  end
end</code></pre>
<p>We can invoke this macro as:</p>
<pre><code class="elixir">defkv [foo: 1, bar: 2]</code></pre>
<p>However, we can’t invoke it as follows:</p>
<pre><code class="elixir">kv = [foo: 1, bar: 2]
defkv kv</code></pre>
<p>This is because the macro is expecting its arguments to be a
keyword list at <strong>compilation</strong> time. Since in the example above
we are passing the representation of the variable <code class="inline">kv</code>, our
code fails.</p>
<p>This is actually a common pitfall when developing macros. We are
assuming a particular shape in the macro. We can work around it
by unquoting the variable inside the quoted expression:</p>
<pre><code class="elixir">defmacro defkv(kv) do
  quote do
    Enum.each unquote(kv), fn {k, v} -&gt;
      def unquote(k)(), do: unquote(v)
    end
  end
end</code></pre>
<p>If you try to run our new macro, you will notice it won’t
even compile, complaining that the variables <code class="inline">k</code> and <code class="inline">v</code>
do not exist. This is because of the ambiguity: <code class="inline">unquote(k)</code>
can either be an unquote fragment, as previously, or a regular
unquote as in <code class="inline">unquote(kv)</code>.</p>
<p>One solution to this problem is to disable unquoting in the
macro, however, doing that would make it impossible to inject the
<code class="inline">kv</code> representation into the tree. That’s when the <code class="inline">:bind_quoted</code>
option comes to the rescue (again!). By using <code class="inline">:bind_quoted</code>, we
can automatically disable unquoting while still injecting the
desired variables into the tree:</p>
<pre><code class="elixir">defmacro defkv(kv) do
  quote bind_quoted: [kv: kv] do
    Enum.each kv, fn {k, v} -&gt;
      def unquote(k)(), do: unquote(v)
    end
  end
end</code></pre>
<p>In fact, the <code class="inline">:bind_quoted</code> option is recommended every time
one desires to inject a value into the quote.</p>

  </section>
</div>
<div class="detail" id="receive/1">
  
  <div class="detail-header">
    <a href="#receive/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">receive(args)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1881" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Checks if there is a message matching the given clauses
in the current process mailbox.</p>
<p>In case there is no such message, the current process hangs
until a message arrives or waits until a given timeout value.</p>
<h2 id="receive/1-examples" class="section-heading">
  <a href="#receive/1-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<pre><code class="elixir">receive do
  {:selector, i, value} when is_integer(i) -&gt;
    value
  value when is_atom(value) -&gt;
    value
  _ -&gt;
    IO.puts :stderr, &quot;Unexpected message received&quot;
end</code></pre>
<p>An optional <code class="inline">after</code> clause can be given in case the message was not
received after the given timeout period, specified in milliseconds:</p>
<pre><code class="elixir">receive do
  {:selector, i, value} when is_integer(i) -&gt;
    value
  value when is_atom(value) -&gt;
    value
  _ -&gt;
    IO.puts :stderr, &quot;Unexpected message received&quot;
after
  5000 -&gt;
    IO.puts :stderr, &quot;No message in 5 seconds&quot;
end</code></pre>
<p>The <code class="inline">after</code> clause can be specified even if there are no match clauses.
The timeout value given to <code class="inline">after</code> can be a variable; two special
values are allowed:</p>
<ul>
<li><p><code class="inline">:infinity</code> - the process should wait indefinitely for a matching
message, this is the same as not using a timeout</p>
</li>
<li><p><code class="inline">0</code> - if there is no matching message in the mailbox, the timeout
will occur immediately</p>
</li>
</ul>
<h2 id="receive/1-variables-handling" class="section-heading">
  <a href="#receive/1-variables-handling" class="hover-link"><i class="icon-link"></i></a>
  Variables handling
</h2>

<p>The <a href="#receive/1"><code class="inline">receive/1</code></a> special form handles variables exactly as the <a href="#case/2"><code class="inline">case/2</code></a>
special macro. For more information, check the docs for <a href="#case/2"><code class="inline">case/2</code></a>.</p>

  </section>
</div>
<div class="detail" id="require/2">
  
  <div class="detail-header">
    <a href="#require/2" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">require(module, opts)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L513" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Requires a given module to be compiled and loaded.</p>
<h2 id="require/2-examples" class="section-heading">
  <a href="#require/2-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<p>Notice that usually modules should not be required before usage,
the only exception is if you want to use the macros from a module.
In such cases, you need to explicitly require them.</p>
<p>Let’s suppose you created your own <code class="inline">if/2</code> implementation in the module
<code class="inline">MyMacros</code>. If you want to invoke it, you need to first explicitly
require the <code class="inline">MyMacros</code>:</p>
<pre><code class="elixir">defmodule Math do
  require MyMacros
  MyMacros.if do_something, it_works
end</code></pre>
<p>An attempt to call a macro that was not loaded will raise an error.</p>
<h2 id="require/2-alias-shortcut" class="section-heading">
  <a href="#require/2-alias-shortcut" class="hover-link"><i class="icon-link"></i></a>
  Alias shortcut
</h2>

<p><a href="#require/2"><code class="inline">require/2</code></a> also accepts <code class="inline">as:</code> as an option so it automatically sets
up an alias. Please check <a href="#alias/2"><code class="inline">alias/2</code></a> for more information.</p>

  </section>
</div>
<div class="detail" id="super/1">
  
  <div class="detail-header">
    <a href="#super/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">super(args)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1491" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Calls the overridden function when overriding it with <a href="Kernel.html#defoverridable/1"><code class="inline">Kernel.defoverridable/1</code></a>.</p>
<p>See <a href="Kernel.html#defoverridable/1"><code class="inline">Kernel.defoverridable/1</code></a> for more information and documentation.</p>

  </section>
</div>
<div class="detail" id="try/1">
  
  <div class="detail-header">
    <a href="#try/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">try(args)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1831" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Evaluates the given expressions and handles any error, exit
or throw that may have happened.</p>
<h2 id="try/1-examples" class="section-heading">
  <a href="#try/1-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<pre><code class="elixir">try do
  do_something_that_may_fail(some_arg)
rescue
  ArgumentError -&gt;
    IO.puts &quot;Invalid argument given&quot;
catch
  value -&gt;
    IO.puts &quot;caught #{value}&quot;
else
  value -&gt;
    IO.puts &quot;Success! The result was #{value}&quot;
after
  IO.puts &quot;This is printed regardless if it failed or succeed&quot;
end</code></pre>
<p>The rescue clause is used to handle exceptions, while the catch
clause can be used to catch thrown values. The else clause can
be used to control flow based on the result of the expression.
Catch, rescue and else clauses work based on pattern matching.</p>
<p>Note that calls inside <a href="#try/1"><code class="inline">try/1</code></a> are not tail recursive since the VM
needs to keep the stacktrace in case an exception happens.</p>
<h2 id="try/1-rescue-clauses" class="section-heading">
  <a href="#try/1-rescue-clauses" class="hover-link"><i class="icon-link"></i></a>
  Rescue clauses
</h2>

<p>Besides relying on pattern matching, rescue clauses provides some
conveniences around exceptions that allows one to rescue an
exception by its name. All the following formats are valid rescue
expressions:</p>
<pre><code class="elixir">try do
  UndefinedModule.undefined_function
rescue
  UndefinedFunctionError -&gt; nil
end

try do
  UndefinedModule.undefined_function
rescue
  [UndefinedFunctionError] -&gt; nil
end

# rescue and bind to x
try do
  UndefinedModule.undefined_function
rescue
  x in [UndefinedFunctionError] -&gt; nil
end

# rescue all and bind to x
try do
  UndefinedModule.undefined_function
rescue
  x -&gt; nil
end</code></pre>
<h2 id="try/1-erlang-errors" class="section-heading">
  <a href="#try/1-erlang-errors" class="hover-link"><i class="icon-link"></i></a>
  Erlang errors
</h2>

<p>Erlang errors are transformed into Elixir ones during rescue:</p>
<pre><code class="elixir">try do
  :erlang.error(:badarg)
rescue
  ArgumentError -&gt; :ok
end</code></pre>
<p>The most common Erlang errors will be transformed into their
Elixir counter-part. Those which are not will be transformed
into <a href="ErlangError.html"><code class="inline">ErlangError</code></a>:</p>
<pre><code class="elixir">try do
  :erlang.error(:unknown)
rescue
  ErlangError -&gt; :ok
end</code></pre>
<p>In fact, <a href="ErlangError.html"><code class="inline">ErlangError</code></a> can be used to rescue any error that is
not an Elixir error proper. For example, it can be used to rescue
the earlier <code class="inline">:badarg</code> error too, prior to transformation:</p>
<pre><code class="elixir">try do
  :erlang.error(:badarg)
rescue
  ErlangError -&gt; :ok
end</code></pre>
<h2 id="try/1-catching-throws-and-exits" class="section-heading">
  <a href="#try/1-catching-throws-and-exits" class="hover-link"><i class="icon-link"></i></a>
  Catching throws and exits
</h2>

<p>The catch clause can be used to catch throws values and exits.</p>
<pre><code class="elixir">try do
  exit(:shutdown)
catch
  :exit, :shutdown -&gt; IO.puts &quot;Exited with shutdown reason&quot;
end

try do
  throw(:sample)
catch
  :throw, :sample -&gt;
    IO.puts &quot;sample thrown&quot;
end</code></pre>
<p>catch values also support <code class="inline">:error</code>, as in Erlang, although it is
commonly avoided in favor of raise/rescue control mechanisms.</p>
<h2 id="try/1-after-clauses" class="section-heading">
  <a href="#try/1-after-clauses" class="hover-link"><i class="icon-link"></i></a>
  After clauses
</h2>

<p>An <code class="inline">after</code> clause allows you to define cleanup logic that will be invoked both
when the tried block of code succeeds and also when an error is raised. Note
that the process will exit as usually when receiving an exit signal that causes
it to exit abruptly and so the <code class="inline">after</code> clause is not guaranteed to be executed.
Luckily, most resources in Elixir (such as open files, ETS tables, ports, sockets,
etc.) are linked to or monitor the owning process and will automatically clean
themselves up if that process exits.</p>
<pre><code class="elixir">File.write!(&quot;tmp/story.txt&quot;, &quot;Hello, World&quot;)
try do
  do_something_with(&quot;tmp/story.txt&quot;)
after
  File.rm(&quot;tmp/story.txt&quot;)
end</code></pre>
<h2 id="try/1-else-clauses" class="section-heading">
  <a href="#try/1-else-clauses" class="hover-link"><i class="icon-link"></i></a>
  Else clauses
</h2>

<p>Else clauses allow the result of the expression to be pattern
matched on:</p>
<pre><code class="elixir">x = 2
try do
  1 / x
rescue
  ArithmeticError -&gt;
    :infinity
else
  y when y &lt; 1 and y &gt; -1 -&gt;
    :small
  _ -&gt;
    :large
end</code></pre>
<p>If an else clause is not present and no exceptions are raised,
the result of the expression will be returned:</p>
<pre><code class="elixir">x = 1
^x =
  try do
    1 / x
  rescue
    ArithmeticError -&gt;
      :infinity
  end</code></pre>
<p>However, when an else clause is present but the result of the expression
does not match any of the patterns an exception will be raised. This
exception will not be caught by a catch or rescue in the same try:</p>
<pre><code class="elixir">x = 1
try do
  try do
    1 / x
  rescue
    # The TryClauseError can not be rescued here:
    TryClauseError -&gt;
      :error_a
  else
    0 -&gt;
      :small
  end
rescue
  # The TryClauseError is rescued here:
  TryClauseError -&gt;
    :error_b
end</code></pre>
<p>Similarly, an exception inside an else clause is not caught or rescued
inside the same try:</p>
<pre><code class="elixir">try do
  try do
    nil
  catch
    # The exit(1) call below can not be caught here:
    :exit, _ -&gt;
      :exit_a
  else
    _ -&gt;
      exit(1)
  end
catch
  # The exit is caught here:
  :exit, _ -&gt;
    :exit_b
end</code></pre>
<p>This means the VM no longer needs to keep the stacktrace once inside
an else clause and so tail recursion is possible when using a <code class="inline">try</code>
with a tail call as the final call inside an else clause. The same
is true for <code class="inline">rescue</code> and <code class="inline">catch</code> clauses.</p>
<h2 id="try/1-variable-handling" class="section-heading">
  <a href="#try/1-variable-handling" class="hover-link"><i class="icon-link"></i></a>
  Variable handling
</h2>

<p>Since an expression inside <code class="inline">try</code> may not have been evaluated
due to an exception, any variable created inside <code class="inline">try</code> cannot
be accessed externally. For instance:</p>
<pre><code class="elixir">try do
  x = 1
  do_something_that_may_fail(same_arg)
  :ok
catch
  _, _ -&gt; :failed
end

x #=&gt; unbound variable &quot;x&quot;</code></pre>
<p>In the example above, <code class="inline">x</code> cannot be accessed since it was defined
inside the <code class="inline">try</code> clause. A common practice to address this issue
is to return the variables defined inside <code class="inline">try</code>:</p>
<pre><code class="elixir">x =
  try do
    x = 1
    do_something_that_may_fail(same_arg)
    x
  catch
    _, _ -&gt; :failed
  end</code></pre>

  </section>
</div>
<div class="detail" id="unquote/1">
  
  <div class="detail-header">
    <a href="#unquote/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">unquote(expr)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1210" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Unquotes the given expression from inside a macro.</p>
<h2 id="unquote/1-examples" class="section-heading">
  <a href="#unquote/1-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<p>Imagine the situation you have a variable <code class="inline">value</code> and
you want to inject it inside some quote. The first attempt
would be:</p>
<pre><code class="elixir">value = 13
quote do
  sum(1, value, 3)
end</code></pre>
<p>Which would then return:</p>
<pre><code class="elixir">{:sum, [], [1, {:value, [], quoted}, 3]}</code></pre>
<p>Which is not the expected result. For this, we use unquote:</p>
<pre><code class="iex elixir">iex&gt; value = 13
iex&gt; quote do
...&gt;   sum(1, unquote(value), 3)
...&gt; end
{:sum, [], [1, 13, 3]}</code></pre>

  </section>
</div>
<div class="detail" id="unquote_splicing/1">
  
  <div class="detail-header">
    <a href="#unquote_splicing/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">unquote_splicing(expr)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1225" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Unquotes the given list expanding its arguments. Similar
to <a href="#unquote/1"><code class="inline">unquote/1</code></a>.</p>
<h2 id="unquote_splicing/1-examples" class="section-heading">
  <a href="#unquote_splicing/1-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<pre><code class="iex elixir">iex&gt; values = [2, 3, 4]
iex&gt; quote do
...&gt;   sum(1, unquote_splicing(values), 5)
...&gt; end
{:sum, [], [1, 2, 3, 4, 5]}</code></pre>

  </section>
</div>
<div class="detail" id="with/1">
  
  <div class="detail-header">
    <a href="#with/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">with(args)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L1352" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Used to combine matching clauses.</p>
<p>Let’s start with an example:</p>
<pre><code class="iex elixir">iex&gt; opts = %{width: 10, height: 15}
iex&gt; with {:ok, width} &lt;- Map.fetch(opts, :width),
...&gt;      {:ok, height} &lt;- Map.fetch(opts, :height),
...&gt;      do: {:ok, width * height}
{:ok, 150}</code></pre>
<p>If all clauses match, the <code class="inline">do</code> block is executed, returning its result.
Otherwise the chain is aborted and the non-matched value is returned:</p>
<pre><code class="iex elixir">iex&gt; opts = %{width: 10}
iex&gt; with {:ok, width} &lt;- Map.fetch(opts, :width),
...&gt;      {:ok, height} &lt;- Map.fetch(opts, :height),
...&gt;      do: {:ok, width * height}
:error</code></pre>
<p>Guards can be used in patterns as well:</p>
<pre><code class="iex elixir">iex&gt; users = %{&quot;melany&quot; =&gt; &quot;guest&quot;, &quot;bob&quot; =&gt; :admin}
iex&gt; with {:ok, role} when not is_binary(role) &lt;- Map.fetch(users, &quot;bob&quot;),
...&gt;      do: {:ok, to_string(role)}
{:ok, &quot;admin&quot;}</code></pre>
<p>As in <a href="#for/1"><code class="inline">for/1</code></a>, variables bound inside <a href="#with/1"><code class="inline">with/1</code></a> won’t leak;
“bare expressions” may also be inserted between the clauses:</p>
<pre><code class="iex elixir">iex&gt; width = nil
iex&gt; opts = %{width: 10, height: 15}
iex&gt; with {:ok, width} &lt;- Map.fetch(opts, :width),
...&gt;      double_width = width * 2,
...&gt;      {:ok, height} &lt;- Map.fetch(opts, :height),
...&gt;      do: {:ok, double_width * height}
{:ok, 300}
iex&gt; width
nil</code></pre>
<p>An <code class="inline">else</code> option can be given to modify what is being returned from
<code class="inline">with</code> in the case of a failed match:</p>
<pre><code class="iex elixir">iex&gt; opts = %{width: 10}
iex&gt; with {:ok, width} &lt;- Map.fetch(opts, :width),
...&gt;      {:ok, height} &lt;- Map.fetch(opts, :height) do
...&gt;   {:ok, width * height}
...&gt; else
...&gt;   :error -&gt;
...&gt;     {:error, :wrong_data}
...&gt; end
{:error, :wrong_data}</code></pre>
<p>If there is no matching <code class="inline">else</code> condition, then a <a href="WithClauseError.html"><code class="inline">WithClauseError</code></a> exception is raised.</p>

  </section>
</div>
<div class="detail" id="%7B%7D/1">
  
  <div class="detail-header">
    <a href="#%7B%7D/1" class="detail-link" title="Link to this macro">
      <i class="icon-link"></i>
    </a>
    <span class="signature">{args}</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/kernel/special_forms.ex#L52" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
      <span class="note">(macro)</span>
    
    
  </div>
  <section class="docstring">
    <p>Creates a tuple.</p>
<p>More information about the tuple data type and about functions to manipulate
tuples can be found in the <a href="Tuple.html"><code class="inline">Tuple</code></a> module; some functions for working with
tuples are also available in <a href="Kernel.html"><code class="inline">Kernel</code></a> (such as <a href="Kernel.html#elem/2"><code class="inline">Kernel.elem/2</code></a> or
<a href="Kernel.html#tuple_size/1"><code class="inline">Kernel.tuple_size/1</code></a>).</p>
<h2 id="%7B%7D/1-ast-representation" class="section-heading">
  <a href="#%7B%7D/1-ast-representation" class="hover-link"><i class="icon-link"></i></a>
  AST representation
</h2>

<p>Only two-item tuples are considered literals in Elixir and return themselves
when quoted. Therefore, all other tuples are represented in the AST as calls to
the <code class="inline">:{}</code> special form.</p>
<pre><code class="iex elixir">iex&gt; quote do
...&gt;   {1, 2}
...&gt; end
{1, 2}

iex&gt; quote do
...&gt;   {1, 2, 3}
...&gt; end
{:{}, [], [1, 2, 3]}</code></pre>

  </section>
</div>

        </section>
      

      
          <footer class="footer">
        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" rel="help" target="_blank">ExDoc</a> (v0.15.1),
          </span>
          <span class="line">
            designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" title="@dignifiedquire">Friedel Ziegelmayer</a>.
            </span>
        </p>
        <button class="night-mode-toggle" />
      </footer>
    </div>
  </div>
</section>
</div>
  <script src="dist/app-048fd787ee.js"></script>
  </body>
</html>


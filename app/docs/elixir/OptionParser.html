    <!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.15.1">
    <title>OptionParser – Elixir v1.4.4</title>
    <link rel="stylesheet" href="dist/app-af302bfcc4.css" />
    
      <link rel="canonical" href="https://hexdocs.pm/elixir/OptionParser.html" />
    
    <script src="dist/sidebar_items-74d75774da.js"></script>
  </head>
  <body data-type="modules">
    <script>try { if(localStorage.getItem('night-mode')) document.body.className += ' night-mode'; } catch (e) { }</script>

    <div class="main">
<button class="sidebar-toggle">
  <i class="icon-menu"></i>
</button>
<section class="sidebar">

  
  <a href="http://elixir-lang.org/docs.html" class="sidebar-projectLink">
    <div class="sidebar-projectDetails">
      <h1 class="sidebar-projectName">
        Elixir
      </h1>
      <h2 class="sidebar-projectVersion">
        v1.4.4
      </h2>
    </div>
    
      <img src="assets/logo.png" alt="Elixir" class="sidebar-projectImage">
    
  </a>

  <div class="sidebar-search">
    <i class="icon-search"></i>
    <input type="text" class="sidebar-searchInput" placeholder="search" autocomplete="off" />
  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list" href="#full-list">Pages</a></li>

    
      <li><a id="modules-list" href="#full-list">Modules</a></li>
    

    
      <li><a id="exceptions-list" href="#full-list">Exceptions</a></li>
    

    
      <li><a id="protocols-list" href="#full-list">Protocols</a></li>
    
  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">


      <h1>
        <small class="visible-xs">Elixir v1.4.4</small>
        OptionParser
        
        
          <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/option_parser.ex#L1" title="View Source" class="view-source" rel="help">
            <i class="icon-code"></i>
          </a>
        
      </h1>

      
        <section id="moduledoc">
          <p>This module contains functions to parse command line options.</p>

        </section>
      

      
        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <i class="icon-link"></i>
            </a>
            Summary
          </h1>
          
  <div class="summary-types summary">
    <h2>
      <a href="#types">Types</a>
    </h2>
    <div class="summary-row">
  <div class="summary-signature">
    <a href="#t:argv/0">argv()</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:errors/0">errors()</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:options/0">options()</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#t:parsed/0">parsed()</a>
  </div>
  
</div>

  </div>


          
  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
    <div class="summary-row">
  <div class="summary-signature">
    <a href="#get_option_key/2">get_option_key(option, allow_nonexistent_atoms?)</a>
  </div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#next/2">next(argv, opts \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Low-level function that parses one option</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#parse/2">parse(argv, opts \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Parses <code class="inline">argv</code> into a keyword list</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#parse!/2">parse!(argv, opts \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>The same as <a href="#parse/2"><code class="inline">parse/2</code></a> but raises an <a href="OptionParser.ParseError.html"><code class="inline">OptionParser.ParseError</code></a>
exception if any invalid options are given</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#parse_head/2">parse_head(argv, opts \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Similar to <a href="#parse/2"><code class="inline">parse/2</code></a> but only parses the head of <code class="inline">argv</code>;
as soon as it finds a non-switch, it stops parsing</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#parse_head!/2">parse_head!(argv, opts \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>The same as <a href="#parse_head/2"><code class="inline">parse_head/2</code></a> but raises an <a href="OptionParser.ParseError.html"><code class="inline">OptionParser.ParseError</code></a>
exception if any invalid options are given</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#split/1">split(string)</a>
  </div>
  
    <div class="summary-synopsis"><p>Splits a string into <a href="#t:argv/0"><code class="inline">argv/0</code></a> chunks</p>
</div>
  
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#to_argv/2">to_argv(enum, opts \\ [])</a>
  </div>
  
    <div class="summary-synopsis"><p>Receives a key-value enumerable and converts it to <a href="#t:argv/0"><code class="inline">argv/0</code></a></p>
</div>
  
</div>

  </div>


          

        </section>
      

      
        <section id="types" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#types">
              <i class="icon-link"></i>
            </a>
            Types
          </h1>
          <div class="types-list">
            <div class="detail" id="t:argv/0">
  
  <div class="detail-header">
    <a href="#t:argv/0" class="detail-link" title="Link to this type">
      <i class="icon-link"></i>
    </a>
    <span class="signature">argv()</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/option_parser.ex#L6" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
    
      <div class="specs">
        
          <pre>argv() :: [<a href="String.html#t:t/0">String.t</a>]</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    
  </section>
</div>
<div class="detail" id="t:errors/0">
  
  <div class="detail-header">
    <a href="#t:errors/0" class="detail-link" title="Link to this type">
      <i class="icon-link"></i>
    </a>
    <span class="signature">errors()</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/option_parser.ex#L8" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
    
      <div class="specs">
        
          <pre>errors() :: [{<a href="String.html#t:t/0">String.t</a>, <a href="String.html#t:t/0">String.t</a> | nil}]</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    
  </section>
</div>
<div class="detail" id="t:options/0">
  
  <div class="detail-header">
    <a href="#t:options/0" class="detail-link" title="Link to this type">
      <i class="icon-link"></i>
    </a>
    <span class="signature">options()</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/option_parser.ex#L9" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
    
      <div class="specs">
        
          <pre>options() :: [switches: <a href="Keyword.html#t:t/0">Keyword.t</a>, strict: <a href="Keyword.html#t:t/0">Keyword.t</a>, aliases: <a href="Keyword.html#t:t/0">Keyword.t</a>]</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    
  </section>
</div>
<div class="detail" id="t:parsed/0">
  
  <div class="detail-header">
    <a href="#t:parsed/0" class="detail-link" title="Link to this type">
      <i class="icon-link"></i>
    </a>
    <span class="signature">parsed()</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/option_parser.ex#L7" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
    
      <div class="specs">
        
          <pre>parsed() :: <a href="Keyword.html#t:t/0">Keyword.t</a></pre>
        
      </div>
    
  </div>
  <section class="docstring">
    
  </section>
</div>

          </div>
        </section>
      

      
        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <i class="icon-link"></i>
            </a>
            Functions
          </h1>
          <div class="detail" id="get_option_key/2">
  
  <div class="detail-header">
    <a href="#get_option_key/2" class="detail-link" title="Link to this function">
      <i class="icon-link"></i>
    </a>
    <span class="signature">get_option_key(option, allow_nonexistent_atoms?)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/option_parser.ex#L707" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
    
  </div>
  <section class="docstring">
    
  </section>
</div>
<div class="detail" id="next/2">
  
    <span id="next/1" />
  
  <div class="detail-header">
    <a href="#next/2" class="detail-link" title="Link to this function">
      <i class="icon-link"></i>
    </a>
    <span class="signature">next(argv, opts \\ [])</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/option_parser.ex#L350" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
    
      <div class="specs">
        
          <pre>next(<a href="#t:argv/0">argv</a>, <a href="#t:options/0">options</a>) ::
  {:ok, key :: atom, value :: term, <a href="#t:argv/0">argv</a>} |
  {:invalid, <a href="String.html#t:t/0">String.t</a>, <a href="String.html#t:t/0">String.t</a> | nil, <a href="#t:argv/0">argv</a>} |
  {:undefined, <a href="String.html#t:t/0">String.t</a>, <a href="String.html#t:t/0">String.t</a> | nil, <a href="#t:argv/0">argv</a>} |
  {:error, <a href="#t:argv/0">argv</a>}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Low-level function that parses one option.</p>
<p>It accepts the same options as <a href="#parse/2"><code class="inline">parse/2</code></a> and <a href="#parse_head/2"><code class="inline">parse_head/2</code></a>
as both functions are built on top of this function. This function
may return:</p>
<ul>
<li><p><code class="inline">{:ok, key, value, rest}</code> - the option <code class="inline">key</code> with <code class="inline">value</code> was
successfully parsed</p>
</li>
<li><p><code class="inline">{:invalid, key, value, rest}</code> - the option <code class="inline">key</code> is invalid with <code class="inline">value</code>
(returned when the value cannot be parsed according to the switch type)</p>
</li>
<li><p><code class="inline">{:undefined, key, value, rest}</code> - the option <code class="inline">key</code> is undefined
(returned in strict mode when the switch is unknown)</p>
</li>
<li><p><code class="inline">{:error, rest}</code> - there are no switches at the head of the given <code class="inline">argv</code></p>
</li>
</ul>

  </section>
</div>
<div class="detail" id="parse/2">
  
    <span id="parse/1" />
  
  <div class="detail-header">
    <a href="#parse/2" class="detail-link" title="Link to this function">
      <i class="icon-link"></i>
    </a>
    <span class="signature">parse(argv, opts \\ [])</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/option_parser.ex#L195" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
    
      <div class="specs">
        
          <pre>parse(<a href="#t:argv/0">argv</a>, <a href="#t:options/0">options</a>) :: {<a href="#t:parsed/0">parsed</a>, <a href="#t:argv/0">argv</a>, <a href="#t:errors/0">errors</a>}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Parses <code class="inline">argv</code> into a keyword list.</p>
<p>It returns a three-element tuple with the form <code class="inline">{parsed, args, invalid}</code>, where:</p>
<ul>
<li><code class="inline">parsed</code> is a keyword list of parsed switches with <code class="inline">{switch_name, value}</code>
tuples in it; <code class="inline">switch_name</code> is the atom representing the switch name while
<code class="inline">value</code> is the value for that switch parsed according to <code class="inline">opts</code> (see the
“Examples” section for more information)
</li>
<li><code class="inline">args</code> is a list of the remaining arguments in <code class="inline">argv</code> as strings
</li>
<li><code class="inline">invalid</code> is a list of invalid options as <code class="inline">{option_name, value}</code> where
<code class="inline">option_name</code> is the raw option and <code class="inline">value</code> is <code class="inline">nil</code> if the option wasn’t
expected or the string value if the value didn’t have the expected type for
the corresponding option
</li>
</ul>
<p>Elixir converts switches to underscored atoms, so <code class="inline">--source-path</code> becomes
<code class="inline">:source_path</code>. This is done to better suit Elixir conventions. However, this
means that switches can’t contain underscores and switches that do contain
underscores are always returned in the list of invalid switches.</p>
<p>When parsing, it is common to list switches and their expected types:</p>
<pre><code class="iex elixir">iex&gt; OptionParser.parse([&quot;--debug&quot;], switches: [debug: :boolean])
{[debug: true], [], []}

iex&gt; OptionParser.parse([&quot;--source&quot;, &quot;lib&quot;], switches: [source: :string])
{[source: &quot;lib&quot;], [], []}

iex&gt; OptionParser.parse([&quot;--source-path&quot;, &quot;lib&quot;, &quot;test/enum_test.exs&quot;, &quot;--verbose&quot;],
...&gt;                    switches: [source_path: :string, verbose: :boolean])
{[source_path: &quot;lib&quot;, verbose: true], [&quot;test/enum_test.exs&quot;], []}</code></pre>
<p>We will explore the valid switches and operation modes of option parser below.</p>
<h2 id="parse/2-options" class="section-heading">
  <a href="#parse/2-options" class="hover-link"><i class="icon-link"></i></a>
  Options
</h2>

<p>The following options are supported:</p>
<ul>
<li><code class="inline">:switches</code> or <code class="inline">:strict</code> - see the “Switch definitions” section below
</li>
<li><code class="inline">:allow_nonexistent_atoms</code> - see the “Parsing dynamic switches” section below
</li>
<li><code class="inline">:aliases</code> - see the “Aliases” section below
</li>
</ul>
<h2 id="parse/2-switch-definitions" class="section-heading">
  <a href="#parse/2-switch-definitions" class="hover-link"><i class="icon-link"></i></a>
  Switch definitions
</h2>

<p>Switches can be specified via one of two options:</p>
<ul>
<li><code class="inline">:switches</code> - defines some switches and their types. This function
still attempts to parse switches that are not in this list.
</li>
<li><code class="inline">:strict</code> - defines strict switches. Any switch in <code class="inline">argv</code> that is not
specified in the list is returned in the invalid options list.
</li>
</ul>
<p>Both these options accept a keyword list of <code class="inline">{name, type}</code> tuples where <code class="inline">name</code>
is an atom defining the name of the switch and <code class="inline">type</code> is an atom that
specifies the type for the value of this switch (see the “Types” section below
for the possible types and more information about type casting).</p>
<p>Note that you should only supply the <code class="inline">:switches</code> or the<code class="inline">:strict</code> option.
If you supply both, an <a href="ArgumentError.html"><code class="inline">ArgumentError</code></a> exception will be raised.</p>
<h3>Types</h3>
<p>Switches parsed by <a href="OptionParser.html#content"><code class="inline">OptionParser</code></a> may take zero or one arguments.</p>
<p>The following switches types take no arguments:</p>
<ul>
<li><code class="inline">:boolean</code> - sets the value to <code class="inline">true</code> when given (see also the
“Negation switches” section below)
</li>
<li><code class="inline">:count</code> - counts the number of times the switch is given
</li>
</ul>
<p>The following switches take one argument:</p>
<ul>
<li><code class="inline">:integer</code> - parses the value as an integer
</li>
<li><code class="inline">:float</code> - parses the value as a float
</li>
<li><code class="inline">:string</code> - parses the value as a string
</li>
</ul>
<p>If a switch can’t be parsed according to the given type, it is
returned in the invalid options list.</p>
<h3>Modifiers</h3>
<p>Switches can be specified with modifiers, which change how
they behave. The following modifiers are supported:</p>
<ul>
<li><code class="inline">:keep</code> - keeps duplicated items instead of overriding them;
works with all types except <code class="inline">:count</code>. Specifying <code class="inline">switch_name: :keep</code>
assumes the type of <code class="inline">:switch_name</code> will be <code class="inline">:string</code>.
</li>
</ul>
<p>To use <code class="inline">:keep</code> with a type other than <code class="inline">:string</code>, use a list as the type
for the switch. For example: <code class="inline">[foo: [:integer, :keep]]</code>.</p>
<h3>Negation switches</h3>
<p>In case a switch <code class="inline">SWITCH</code> is specified to have type <code class="inline">:boolean</code>, it may be
passed as <code class="inline">--no-SWITCH</code> as well which will set the option to <code class="inline">false</code>:</p>
<pre><code class="iex elixir">iex&gt; OptionParser.parse([&quot;--no-op&quot;, &quot;path/to/file&quot;], switches: [op: :boolean])
{[op: false], [&quot;path/to/file&quot;], []}</code></pre>
<h3>Parsing dynamic switches</h3>
<p><a href="OptionParser.html#content"><code class="inline">OptionParser</code></a> also includes a dynamic mode where it will attempt to parse
switches dynamically. Such can be done by not specifying the <code class="inline">:switches</code> or
<code class="inline">:strict</code> option.</p>
<pre><code class="iex elixir">iex&gt; OptionParser.parse([&quot;--debug&quot;])
{[debug: true], [], []}</code></pre>
<p>Switches followed by a value will be assigned the value, as a string. Switches
without an argument, like <code class="inline">--debug</code> in the examples above, will automatically be
set to <code class="inline">true</code>.</p>
<p>Since Elixir converts switches to atoms, the dynamic mode will only parse
switches that translates to atoms used by the runtime. Therefore, the code below
likely won’t parse the given option since the <code class="inline">:option_parser_example</code> atom is
never used anywhere:</p>
<pre><code class="elixir">OptionParser.parse([&quot;--option-parser-example&quot;])
# Does nothing more...</code></pre>
<p>However, the code below does since the <code class="inline">:option_parser_example</code> atom is used
at some point later (or earlier) on:</p>
<pre><code class="elixir">{opts, _, _} = OptionParser.parse([&quot;--option-parser-example&quot;])
opts[:option_parser_example]</code></pre>
<p>In other words, when using dynamic mode, Elixir will do the correct thing and
only parse options that are used by the runtime, ignoring all others. If you
would like to parse all switches, regardless if they exist or not, you can
force creation of atoms by passing <code class="inline">allow_nonexistent_atoms: true</code> as option.
Such option is useful when you are building command-line applications that
receive dynamically-named arguments but must be used with care on long-running
systems.</p>
<p>Switches followed by a value will be assigned the value, as a string.
Switches without an argument, like <code class="inline">--debug</code> in the examples above, will
automatically be set to <code class="inline">true</code>.</p>
<h2 id="parse/2-aliases" class="section-heading">
  <a href="#parse/2-aliases" class="hover-link"><i class="icon-link"></i></a>
  Aliases
</h2>

<p>A set of aliases can be specified in the <code class="inline">:aliases</code> option:</p>
<pre><code class="iex elixir">iex&gt; OptionParser.parse([&quot;-d&quot;], aliases: [d: :debug])
{[debug: true], [], []}</code></pre>
<h2 id="parse/2-examples" class="section-heading">
  <a href="#parse/2-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<p>Here are some examples of working with different types and modifiers:</p>
<pre><code class="iex elixir">iex&gt; OptionParser.parse([&quot;--unlock&quot;, &quot;path/to/file&quot;], strict: [unlock: :boolean])
{[unlock: true], [&quot;path/to/file&quot;], []}

iex&gt; OptionParser.parse([&quot;--unlock&quot;, &quot;--limit&quot;, &quot;0&quot;, &quot;path/to/file&quot;],
...&gt;                    strict: [unlock: :boolean, limit: :integer])
{[unlock: true, limit: 0], [&quot;path/to/file&quot;], []}

iex&gt; OptionParser.parse([&quot;--limit&quot;, &quot;3&quot;], strict: [limit: :integer])
{[limit: 3], [], []}

iex&gt; OptionParser.parse([&quot;--limit&quot;, &quot;xyz&quot;], strict: [limit: :integer])
{[], [], [{&quot;--limit&quot;, &quot;xyz&quot;}]}

iex&gt; OptionParser.parse([&quot;--verbose&quot;], switches: [verbose: :count])
{[verbose: 1], [], []}

iex&gt; OptionParser.parse([&quot;-v&quot;, &quot;-v&quot;], aliases: [v: :verbose], strict: [verbose: :count])
{[verbose: 2], [], []}

iex&gt; OptionParser.parse([&quot;--unknown&quot;, &quot;xyz&quot;], strict: [])
{[], [&quot;xyz&quot;], [{&quot;--unknown&quot;, nil}]}

iex&gt; OptionParser.parse([&quot;--limit&quot;, &quot;3&quot;, &quot;--unknown&quot;, &quot;xyz&quot;],
...&gt;                    switches: [limit: :integer])
{[limit: 3, unknown: &quot;xyz&quot;], [], []}

iex&gt; OptionParser.parse([&quot;--unlock&quot;, &quot;path/to/file&quot;, &quot;--unlock&quot;, &quot;path/to/another/file&quot;], strict: [unlock: :keep])
{[unlock: &quot;path/to/file&quot;, unlock: &quot;path/to/another/file&quot;], [], []}</code></pre>

  </section>
</div>
<div class="detail" id="parse!/2">
  
    <span id="parse!/1" />
  
  <div class="detail-header">
    <a href="#parse!/2" class="detail-link" title="Link to this function">
      <i class="icon-link"></i>
    </a>
    <span class="signature">parse!(argv, opts \\ [])</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/option_parser.ex#L229" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
    
      <div class="specs">
        
          <pre>parse!(<a href="#t:argv/0">argv</a>, <a href="#t:options/0">options</a>) :: {<a href="#t:parsed/0">parsed</a>, <a href="#t:argv/0">argv</a>} | no_return</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>The same as <a href="#parse/2"><code class="inline">parse/2</code></a> but raises an <a href="OptionParser.ParseError.html"><code class="inline">OptionParser.ParseError</code></a>
exception if any invalid options are given.</p>
<p>If there are no errors, returns a <code class="inline">{parsed, rest}</code> tuple where:</p>
<ul>
<li><code class="inline">parsed</code> is the list of parsed switches (same as in <a href="#parse/2"><code class="inline">parse/2</code></a>)
</li>
<li><code class="inline">rest</code> is the list of arguments (same as in <a href="#parse/2"><code class="inline">parse/2</code></a>)
</li>
</ul>
<h2 id="parse!/2-examples" class="section-heading">
  <a href="#parse!/2-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<pre><code class="iex elixir">iex&gt; OptionParser.parse!([&quot;--debug&quot;, &quot;path/to/file&quot;], strict: [debug: :boolean])
{[debug: true], [&quot;path/to/file&quot;]}

iex&gt; OptionParser.parse!([&quot;--limit&quot;, &quot;xyz&quot;], strict: [limit: :integer])
** (OptionParser.ParseError) 1 error found!
--limit : Expected type integer, got &quot;xyz&quot;

iex&gt; OptionParser.parse!([&quot;--unknown&quot;, &quot;xyz&quot;], strict: [])
** (OptionParser.ParseError) 1 error found!
--unknown : Unknown option

iex&gt; OptionParser.parse!([&quot;-l&quot;, &quot;xyz&quot;, &quot;-f&quot;, &quot;bar&quot;],
...&gt;                     switches: [limit: :integer, foo: :integer], aliases: [l: :limit, f: :foo])
** (OptionParser.ParseError) 2 errors found!
-l : Expected type integer, got &quot;xyz&quot;
-f : Expected type integer, got &quot;bar&quot;</code></pre>

  </section>
</div>
<div class="detail" id="parse_head/2">
  
    <span id="parse_head/1" />
  
  <div class="detail-header">
    <a href="#parse_head/2" class="detail-link" title="Link to this function">
      <i class="icon-link"></i>
    </a>
    <span class="signature">parse_head(argv, opts \\ [])</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/option_parser.ex#L254" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
    
      <div class="specs">
        
          <pre>parse_head(<a href="#t:argv/0">argv</a>, <a href="#t:options/0">options</a>) :: {<a href="#t:parsed/0">parsed</a>, <a href="#t:argv/0">argv</a>, <a href="#t:errors/0">errors</a>}</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Similar to <a href="#parse/2"><code class="inline">parse/2</code></a> but only parses the head of <code class="inline">argv</code>;
as soon as it finds a non-switch, it stops parsing.</p>
<p>See <a href="#parse/2"><code class="inline">parse/2</code></a> for more information.</p>
<h2 id="parse_head/2-example" class="section-heading">
  <a href="#parse_head/2-example" class="hover-link"><i class="icon-link"></i></a>
  Example
</h2>

<pre><code class="iex elixir">iex&gt; OptionParser.parse_head([&quot;--source&quot;, &quot;lib&quot;, &quot;test/enum_test.exs&quot;, &quot;--verbose&quot;],
...&gt;                         switches: [source: :string, verbose: :boolean])
{[source: &quot;lib&quot;], [&quot;test/enum_test.exs&quot;, &quot;--verbose&quot;], []}

iex&gt; OptionParser.parse_head([&quot;--verbose&quot;, &quot;--source&quot;, &quot;lib&quot;, &quot;test/enum_test.exs&quot;, &quot;--unlock&quot;],
...&gt;                         switches: [source: :string, verbose: :boolean, unlock: :boolean])
{[verbose: true, source: &quot;lib&quot;], [&quot;test/enum_test.exs&quot;, &quot;--unlock&quot;], []}</code></pre>

  </section>
</div>
<div class="detail" id="parse_head!/2">
  
    <span id="parse_head!/1" />
  
  <div class="detail-header">
    <a href="#parse_head!/2" class="detail-link" title="Link to this function">
      <i class="icon-link"></i>
    </a>
    <span class="signature">parse_head!(argv, opts \\ [])</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/option_parser.ex#L285" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
    
      <div class="specs">
        
          <pre>parse_head!(<a href="#t:argv/0">argv</a>, <a href="#t:options/0">options</a>) :: {<a href="#t:parsed/0">parsed</a>, <a href="#t:argv/0">argv</a>} | no_return</pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>The same as <a href="#parse_head/2"><code class="inline">parse_head/2</code></a> but raises an <a href="OptionParser.ParseError.html"><code class="inline">OptionParser.ParseError</code></a>
exception if any invalid options are given.</p>
<p>If there are no errors, returns a <code class="inline">{parsed, rest}</code> tuple where:</p>
<ul>
<li><code class="inline">parsed</code> is the list of parsed switches (same as in <a href="#parse_head/2"><code class="inline">parse_head/2</code></a>)
</li>
<li><code class="inline">rest</code> is the list of arguments (same as in <a href="#parse_head/2"><code class="inline">parse_head/2</code></a>)
</li>
</ul>
<h2 id="parse_head!/2-examples" class="section-heading">
  <a href="#parse_head!/2-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<pre><code class="iex elixir">iex&gt; OptionParser.parse_head!([&quot;--source&quot;, &quot;lib&quot;, &quot;path/to/file&quot;, &quot;--verbose&quot;],
...&gt;                         switches: [source: :string, verbose: :boolean])
{[source: &quot;lib&quot;], [&quot;path/to/file&quot;, &quot;--verbose&quot;]}

iex&gt; OptionParser.parse_head!([&quot;--number&quot;, &quot;lib&quot;, &quot;test/enum_test.exs&quot;, &quot;--verbose&quot;],
...&gt;                          strict: [number: :integer])
** (OptionParser.ParseError) 1 error found!
--number : Expected type integer, got &quot;lib&quot;

iex&gt; OptionParser.parse_head!([&quot;--verbose&quot;, &quot;--source&quot;, &quot;lib&quot;, &quot;test/enum_test.exs&quot;, &quot;--unlock&quot;],
...&gt;                          strict: [verbose: :integer, source: :integer])
** (OptionParser.ParseError) 2 errors found!
--verbose : Missing argument of type integer
--source : Expected type integer, got &quot;lib&quot;</code></pre>

  </section>
</div>
<div class="detail" id="split/1">
  
  <div class="detail-header">
    <a href="#split/1" class="detail-link" title="Link to this function">
      <i class="icon-link"></i>
    </a>
    <span class="signature">split(string)</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/option_parser.ex#L488" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
    
      <div class="specs">
        
          <pre>split(<a href="String.html#t:t/0">String.t</a>) :: <a href="#t:argv/0">argv</a></pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Splits a string into <a href="#t:argv/0"><code class="inline">argv/0</code></a> chunks.</p>
<p>This function splits the given <code class="inline">string</code> into a list of strings in a similar
way to many shells.</p>
<h2 id="split/1-examples" class="section-heading">
  <a href="#split/1-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<pre><code class="iex elixir">iex&gt; OptionParser.split(&quot;foo bar&quot;)
[&quot;foo&quot;, &quot;bar&quot;]

iex&gt; OptionParser.split(&quot;foo \&quot;bar baz\&quot;&quot;)
[&quot;foo&quot;, &quot;bar baz&quot;]</code></pre>

  </section>
</div>
<div class="detail" id="to_argv/2">
  
    <span id="to_argv/1" />
  
  <div class="detail-header">
    <a href="#to_argv/2" class="detail-link" title="Link to this function">
      <i class="icon-link"></i>
    </a>
    <span class="signature">to_argv(enum, opts \\ [])</span>
    
      <a href="https://github.com/elixir-lang/elixir/blob/v1.4.4/lib/elixir/lib/option_parser.ex#L450" class="view-source" rel="help" title="View Source">
       <i class="icon-code"></i>
     </a>
    
    
    
      <div class="specs">
        
          <pre>to_argv(<a href="Enumerable.html#t:t/0">Enumerable.t</a>, <a href="#t:options/0">options</a>) :: <a href="#t:argv/0">argv</a></pre>
        
      </div>
    
  </div>
  <section class="docstring">
    <p>Receives a key-value enumerable and converts it to <a href="#t:argv/0"><code class="inline">argv/0</code></a>.</p>
<p>Keys must be atoms. Keys with <code class="inline">nil</code> value are discarded,
boolean values are converted to <code class="inline">--key</code> or <code class="inline">--no-key</code>
(if the value is <code class="inline">true</code> or <code class="inline">false</code>, respectively),
and all other values are converted using <a href="Kernel.html#to_string/1"><code class="inline">Kernel.to_string/1</code></a>.</p>
<p>It is advised to pass to <a href="#to_argv/2"><code class="inline">to_argv/2</code></a> the same set of <code class="inline">options</code>
given to <a href="#parse/2"><code class="inline">parse/2</code></a>. Some switches can only be reconstructed
correctly with the <code class="inline">switches</code> information in hand.</p>
<h2 id="to_argv/2-examples" class="section-heading">
  <a href="#to_argv/2-examples" class="hover-link"><i class="icon-link"></i></a>
  Examples
</h2>

<pre><code class="iex elixir">iex&gt;  OptionParser.to_argv([foo_bar: &quot;baz&quot;])
[&quot;--foo-bar&quot;, &quot;baz&quot;]
iex&gt;  OptionParser.to_argv([bool: true, bool: false, discarded: nil])
[&quot;--bool&quot;, &quot;--no-bool&quot;]</code></pre>
<p>Some switches will output different values based on the switches
flag:</p>
<pre><code class="iex elixir">iex&gt; OptionParser.to_argv([number: 2], switches: [])
[&quot;--number&quot;, &quot;2&quot;]
iex&gt; OptionParser.to_argv([number: 2], switches: [number: :count])
[&quot;--number&quot;, &quot;--number&quot;]</code></pre>

  </section>
</div>

        </section>
      

      
          <footer class="footer">
        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" rel="help" target="_blank">ExDoc</a> (v0.15.1),
          </span>
          <span class="line">
            designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" title="@dignifiedquire">Friedel Ziegelmayer</a>.
            </span>
        </p>
        <button class="night-mode-toggle" />
      </footer>
    </div>
  </div>
</section>
</div>
  <script src="dist/app-048fd787ee.js"></script>
  </body>
</html>

